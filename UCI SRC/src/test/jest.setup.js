import '@testing-library/jest-dom';\nimport { TextEncoder, TextDecoder } from 'util';\nimport { webcrypto } from 'crypto';\n\n// Polyfills for Node.js environment\nglobal.TextEncoder = TextEncoder;\nglobal.TextDecoder = TextDecoder;\nglobal.crypto = webcrypto;\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = class IntersectionObserver {\n  constructor() {}\n  observe() {\n    return null;\n  }\n  disconnect() {\n    return null;\n  }\n  unobserve() {\n    return null;\n  }\n};\n\n// Mock ResizeObserver\nglobal.ResizeObserver = class ResizeObserver {\n  constructor() {}\n  observe() {\n    return null;\n  }\n  disconnect() {\n    return null;\n  }\n  unobserve() {\n    return null;\n  }\n};\n\n// Mock HTMLMediaElement\nObject.defineProperty(window.HTMLMediaElement.prototype, 'muted', {\n  writable: true,\n  value: false,\n});\n\n// Mock Canvas API for face recognition tests\nHTMLCanvasElement.prototype.getContext = jest.fn(() => ({\n  fillRect: jest.fn(),\n  clearRect: jest.fn(),\n  getImageData: jest.fn(() => ({ data: new Array(4) })),\n  putImageData: jest.fn(),\n  createImageData: jest.fn(() => ({ data: new Array(4) })),\n  setTransform: jest.fn(),\n  drawImage: jest.fn(),\n  save: jest.fn(),\n  restore: jest.fn(),\n  beginPath: jest.fn(),\n  moveTo: jest.fn(),\n  lineTo: jest.fn(),\n  closePath: jest.fn(),\n  stroke: jest.fn(),\n  fill: jest.fn(),\n}));\n\n// Mock Web3 and Ethereum\nglobal.ethereum = {\n  isMetaMask: true,\n  request: jest.fn().mockResolvedValue(['0x123']),\n  on: jest.fn(),\n  removeListener: jest.fn(),\n};\n\n// Mock WebRTC for collaboration tests\nglobal.RTCPeerConnection = jest.fn(() => ({\n  createOffer: jest.fn().mockResolvedValue({}),\n  createAnswer: jest.fn().mockResolvedValue({}),\n  setLocalDescription: jest.fn().mockResolvedValue(),\n  setRemoteDescription: jest.fn().mockResolvedValue(),\n  addIceCandidate: jest.fn().mockResolvedValue(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn(),\n  close: jest.fn(),\n}));\n\n// Mock getUserMedia for biometric tests\nObject.defineProperty(navigator, 'mediaDevices', {\n  writable: true,\n  value: {\n    getUserMedia: jest.fn().mockResolvedValue({\n      getTracks: jest.fn(() => [{\n        stop: jest.fn(),\n        kind: 'video',\n        getSettings: jest.fn(() => ({ width: 640, height: 480 })),\n      }]),\n    }),\n    enumerateDevices: jest.fn().mockResolvedValue([\n      { deviceId: 'default', kind: 'videoinput', label: 'Test Camera' }\n    ]),\n  },\n});\n\n// Mock File API\nglobal.File = class File {\n  constructor(chunks, filename, options = {}) {\n    this.chunks = chunks;\n    this.name = filename;\n    this.size = chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n    this.type = options.type || 'text/plain';\n    this.lastModified = Date.now();\n  }\n  \n  stream() {\n    return new ReadableStream({\n      start(controller) {\n        this.chunks.forEach(chunk => controller.enqueue(chunk));\n        controller.close();\n      }\n    });\n  }\n  \n  arrayBuffer() {\n    return Promise.resolve(new ArrayBuffer(this.size));\n  }\n  \n  text() {\n    return Promise.resolve(this.chunks.join(''));\n  }\n};\n\n// Mock IPFS client\njest.mock('ipfs-http-client', () => ({\n  create: jest.fn(() => ({\n    add: jest.fn().mockResolvedValue({ path: 'QmTest123' }),\n    get: jest.fn().mockResolvedValue([{ content: Buffer.from('test') }]),\n    pin: {\n      add: jest.fn().mockResolvedValue({ pins: ['QmTest123'] }),\n    },\n  })),\n}));\n\n// Mock TensorFlow.js\njest.mock('@tensorflow/tfjs', () => ({\n  loadLayersModel: jest.fn().mockResolvedValue({\n    predict: jest.fn().mockReturnValue({\n      data: jest.fn().mockResolvedValue([0.95]),\n    }),\n  }),\n  tensor1d: jest.fn().mockReturnValue({\n    data: jest.fn().mockResolvedValue([0.1, 0.2, 0.3]),\n    expandDims: jest.fn().mockReturnThis(),\n  }),\n  browser: {\n    toPixels: jest.fn().mockResolvedValue(new ImageData(224, 224)),\n  },\n  losses: {\n    cosineDistance: jest.fn().mockReturnValue({\n      data: jest.fn().mockResolvedValue([0.1]),\n    }),\n  },\n}));\n\n// Mock face-api.js\njest.mock('face-api.js', () => ({\n  nets: {\n    ssdMobilenetv1: {\n      loadFromDisk: jest.fn().mockResolvedValue(),\n    },\n    faceLandmark68Net: {\n      loadFromDisk: jest.fn().mockResolvedValue(),\n    },\n    faceRecognitionNet: {\n      loadFromDisk: jest.fn().mockResolvedValue(),\n    },\n  },\n  detectSingleFace: jest.fn().mockResolvedValue({\n    detection: { score: 0.95 },\n  }),\n}));\n\n// Mock Stripe\njest.mock('stripe', () => {\n  return jest.fn(() => ({\n    accounts: {\n      create: jest.fn().mockResolvedValue({ id: 'acct_test123' }),\n      retrieve: jest.fn().mockResolvedValue({ id: 'acct_test123' }),\n    },\n    paymentIntents: {\n      create: jest.fn().mockResolvedValue({\n        id: 'pi_test123',\n        client_secret: 'pi_test123_secret',\n        status: 'requires_payment_method',\n      }),\n    },\n    transfers: {\n      create: jest.fn().mockResolvedValue({ id: 'tr_test123' }),\n    },\n  }));\n});\n\n// Mock ethers\njest.mock('ethers', () => ({\n  ethers: {\n    JsonRpcProvider: jest.fn(() => ({\n      getNetwork: jest.fn().mockResolvedValue({ chainId: 137 }),\n      getBalance: jest.fn().mockResolvedValue('1000000000000000000'),\n    })),\n    Wallet: jest.fn(() => ({\n      address: '0x1234567890123456789012345678901234567890',\n      connect: jest.fn().mockReturnThis(),\n      signMessage: jest.fn().mockResolvedValue('0xsignature'),\n    })),\n    Contract: jest.fn(() => ({\n      deployed: jest.fn().mockResolvedValue(),\n      registerCreator: jest.fn().mockResolvedValue({\n        hash: '0xtxhash',\n        wait: jest.fn().mockResolvedValue({ status: 1 }),\n      }),\n      getCreatorVerificationLevel: jest.fn().mockResolvedValue(85),\n    })),\n    getContractFactory: jest.fn().mockResolvedValue({\n      deploy: jest.fn().mockResolvedValue({\n        deployed: jest.fn().mockResolvedValue(),\n        address: '0xcontractaddress',\n        deployTransaction: {\n          hash: '0xdeployhash',\n        },\n      }),\n    }),\n    parseEther: jest.fn((value) => value),\n    formatEther: jest.fn((value) => value),\n  },\n}));\n\n// Mock Socket.IO Client\njest.mock('socket.io-client', () => {\n  const mockSocket = {\n    on: jest.fn(),\n    emit: jest.fn(),\n    off: jest.fn(),\n    connect: jest.fn(),\n    disconnect: jest.fn(),\n    connected: true,\n  };\n  \n  return jest.fn(() => mockSocket);\n});\n\n// Mock Next.js router\njest.mock('next/router', () => ({\n  useRouter: () => ({\n    route: '/',\n    pathname: '/',\n    query: {},\n    asPath: '/',\n    push: jest.fn(),\n    replace: jest.fn(),\n    reload: jest.fn(),\n    back: jest.fn(),\n    prefetch: jest.fn().mockResolvedValue(undefined),\n    beforePopState: jest.fn(),\n    events: {\n      on: jest.fn(),\n      off: jest.fn(),\n      emit: jest.fn(),\n    },\n  }),\n}));\n\n// Mock environment variables for tests\nprocess.env.NODE_ENV = 'test';\nprocess.env.DATABASE_URL = 'postgresql://test:test@localhost:5432/creative_identity_test';\nprocess.env.REDIS_URL = 'redis://localhost:6379';\nprocess.env.JWT_SECRET = 'test-jwt-secret';\nprocess.env.STRIPE_SECRET_KEY = 'sk_test_123';\nprocess.env.POLYGON_RPC_URL = 'http://localhost:8545';\nprocess.env.PRIVATE_KEY = '0x1234567890123456789012345678901234567890123456789012345678901234';\n\n// Global test helpers\nglobal.createMockCreator = () => ({\n  id: 'test-creator-123',\n  universalId: 'uci_test123',\n  walletAddress: '0x1234567890123456789012345678901234567890',\n  displayName: 'Test Creator',\n  username: 'testcreator',\n  bio: 'Test creator for unit tests',\n  verificationLevel: 85,\n  platformConnections: new Map(),\n  contentCredentials: [],\n  authenticityScore: 95,\n});\n\nglobal.createMockPlatformConnection = (platformId = 'tiktok') => ({\n  platformId,\n  username: `test_${platformId}`,\n  userId: `${platformId}_123`,\n  displayName: 'Test User',\n  profileUrl: `https://${platformId}.com/@testuser`,\n  connectionStatus: 'connected',\n  connectedAt: new Date(),\n  lastSyncAt: new Date(),\n  accessToken: 'encrypted_token',\n  tokenExpiresAt: new Date(Date.now() + 3600000),\n  platformData: {\n    [platformId]: {\n      followerCount: 10000,\n      followingCount: 1000,\n      verified: false,\n    },\n  },\n  metrics: {\n    totalReach: 10000,\n    engagementRate: 5.5,\n    averageViews: 5000,\n    averageLikes: 275,\n    averageComments: 25,\n    averageShares: 50,\n    growthRate: 2.3,\n    lastUpdated: new Date(),\n  },\n  syncSettings: {\n    autoSync: true,\n    syncFrequency: 'daily',\n    syncFields: ['profile', 'content', 'metrics'],\n    conflictResolution: 'latest',\n    privacyLevel: 'public',\n  },\n});\n\n// Test database helpers\nglobal.setupTestDatabase = async () => {\n  // Mock database setup for tests\n  console.log('Setting up test database...');\n};\n\nglobal.cleanupTestDatabase = async () => {\n  // Mock database cleanup for tests\n  console.log('Cleaning up test database...');\n};\n\n// Performance testing helpers\nglobal.measureExecutionTime = async (fn) => {\n  const start = performance.now();\n  const result = await fn();\n  const end = performance.now();\n  return { result, executionTime: end - start };\n};\n\n// Extend Jest matchers for blockchain testing\nexpect.extend({\n  toBeValidEthereumAddress(received) {\n    const pass = /^0x[a-fA-F0-9]{40}$/.test(received);\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be a valid Ethereum address`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () => `expected ${received} to be a valid Ethereum address`,\n        pass: false,\n      };\n    }\n  },\n  \n  toBeValidIPFSHash(received) {\n    const pass = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/.test(received);\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be a valid IPFS hash`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () => `expected ${received} to be a valid IPFS hash`,\n        pass: false,\n      };\n    }\n  },\n  \n  toHaveValidUniversalCreativeID(received) {\n    const pass = /^uci_[a-f0-9]{16}$/.test(received);\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be a valid Universal Creative ID`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () => `expected ${received} to be a valid Universal Creative ID`,\n        pass: false,\n      };\n    }\n  },\n});\n\n// Console suppression for cleaner test output\nconst originalError = console.error;\nconsole.error = (...args) => {\n  if (\n    typeof args[0] === 'string' &&\n    args[0].includes('Warning: ReactDOM.render is no longer supported')\n  ) {\n    return;\n  }\n  originalError.call(console, ...args);\n};"