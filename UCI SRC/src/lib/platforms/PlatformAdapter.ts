import axios, { AxiosInstance } from 'axios';\nimport { PlatformConnection, PlatformSpecificData, PlatformMetrics } from '@/types/identity';\n\n/**\n * Abstract base class for all platform integrations\n * Provides standardized interface for connecting to social media platforms\n */\nexport abstract class PlatformAdapter {\n  abstract readonly platformId: string;\n  abstract readonly apiVersion: string;\n  protected apiClient: AxiosInstance;\n  \n  constructor(baseURL: string, defaultHeaders: Record<string, string> = {}) {\n    this.apiClient = axios.create({\n      baseURL,\n      headers: {\n        'User-Agent': 'CreativeIdentityPlatform/1.0',\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        ...defaultHeaders\n      },\n      timeout: 30000,\n      retry: 3,\n      retryDelay: 1000\n    });\n    \n    // Add request interceptor for authentication\n    this.apiClient.interceptors.request.use(\n      (config) => this.authenticateRequest(config),\n      (error) => Promise.reject(error)\n    );\n    \n    // Add response interceptor for error handling\n    this.apiClient.interceptors.response.use(\n      (response) => response,\n      (error) => this.handleApiError(error)\n    );\n  }\n  \n  // Abstract methods that must be implemented by each platform\n  abstract authenticateUser(authCode: string, redirectUri: string): Promise<PlatformConnection>;\n  abstract refreshToken(connection: PlatformConnection): Promise<PlatformConnection>;\n  abstract fetchProfileData(connection: PlatformConnection): Promise<PlatformSpecificData>;\n  abstract fetchContentData(connection: PlatformConnection, limit?: number): Promise<any[]>;\n  abstract calculateMetrics(profileData: PlatformSpecificData, contentData: any[]): Promise<PlatformMetrics>;\n  abstract validateConnection(connection: PlatformConnection): Promise<boolean>;\n  \n  // Common functionality\n  async syncPlatformData(connection: PlatformConnection): Promise<{\n    profileData: PlatformSpecificData;\n    contentData: any[];\n    metrics: PlatformMetrics;\n    lastSync: Date;\n  }> {\n    try {\n      // Validate connection is still active\n      const isValid = await this.validateConnection(connection);\n      if (!isValid) {\n        throw new Error('Platform connection is no longer valid');\n      }\n      \n      // Fetch profile and content data in parallel\n      const [profileData, contentData] = await Promise.all([\n        this.fetchProfileData(connection),\n        this.fetchContentData(connection, 50)\n      ]);\n      \n      // Calculate metrics\n      const metrics = await this.calculateMetrics(profileData, contentData);\n      \n      return {\n        profileData,\n        contentData,\n        metrics,\n        lastSync: new Date()\n      };\n    } catch (error) {\n      console.error(`Platform sync failed for ${this.platformId}:`, error);\n      throw error;\n    }\n  }\n  \n  protected async authenticateRequest(config: any): Promise<any> {\n    // Default implementation - override in platform-specific adapters\n    return config;\n  }\n  \n  protected async handleApiError(error: any): Promise<never> {\n    if (error.response?.status === 401) {\n      throw new Error('Authentication failed - token may be expired');\n    } else if (error.response?.status === 429) {\n      throw new Error('Rate limit exceeded - please try again later');\n    } else if (error.response?.status >= 500) {\n      throw new Error('Platform API is currently unavailable');\n    }\n    \n    throw error;\n  }\n  \n  protected generateConnectionId(): string {\n    return `${this.platformId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  protected encryptTokens(tokens: { access: string; refresh?: string }): {\n    accessToken: string;\n    refreshToken?: string;\n  } {\n    // In production, use proper encryption\n    return {\n      accessToken: Buffer.from(tokens.access).toString('base64'),\n      refreshToken: tokens.refresh ? Buffer.from(tokens.refresh).toString('base64') : undefined\n    };\n  }\n  \n  protected decryptTokens(encryptedTokens: { accessToken: string; refreshToken?: string }): {\n    access: string;\n    refresh?: string;\n  } {\n    // In production, use proper decryption\n    return {\n      access: Buffer.from(encryptedTokens.accessToken, 'base64').toString(),\n      refresh: encryptedTokens.refreshToken \n        ? Buffer.from(encryptedTokens.refreshToken, 'base64').toString()\n        : undefined\n    };\n  }\n}\n\n/**\n * TikTok Platform Integration\n */\nexport class TikTokAdapter extends PlatformAdapter {\n  readonly platformId = 'tiktok';\n  readonly apiVersion = 'v1';\n  \n  constructor() {\n    super('https://open-api.tiktok.com', {\n      'Client-Key': process.env.TIKTOK_CLIENT_KEY!\n    });\n  }\n  \n  async authenticateUser(authCode: string, redirectUri: string): Promise<PlatformConnection> {\n    try {\n      // Step 1: Exchange auth code for access token\n      const tokenResponse = await this.apiClient.post('/oauth/access_token/', {\n        client_key: process.env.TIKTOK_CLIENT_KEY,\n        client_secret: process.env.TIKTOK_CLIENT_SECRET,\n        code: authCode,\n        grant_type: 'authorization_code',\n        redirect_uri: redirectUri\n      });\n      \n      const { access_token, refresh_token, expires_in, open_id } = tokenResponse.data.data;\n      \n      // Step 2: Fetch user info\n      const userResponse = await this.apiClient.get('/user/info/', {\n        headers: { Authorization: `Bearer ${access_token}` },\n        params: { open_id, fields: 'open_id,union_id,avatar_url,display_name,username,follower_count,following_count,likes_count' }\n      });\n      \n      const userData = userResponse.data.data.user;\n      \n      // Step 3: Create platform connection\n      const connection: PlatformConnection = {\n        platformId: this.platformId,\n        username: userData.username,\n        userId: userData.open_id,\n        displayName: userData.display_name,\n        profileUrl: `https://tiktok.com/@${userData.username}`,\n        \n        connectionStatus: 'connected',\n        connectedAt: new Date(),\n        lastSyncAt: new Date(),\n        \n        accessToken: this.encryptTokens({ access: access_token, refresh: refresh_token }).accessToken,\n        refreshToken: this.encryptTokens({ access: access_token, refresh: refresh_token }).refreshToken,\n        tokenExpiresAt: new Date(Date.now() + expires_in * 1000),\n        \n        platformData: {\n          tiktok: {\n            followerCount: userData.follower_count,\n            followingCount: userData.following_count,\n            likesCount: userData.likes_count,\n            videoCount: 0, // Will be updated during content sync\n            verified: userData.verified || false,\n            bio: userData.bio || '',\n            avatarUrl: userData.avatar_url\n          }\n        },\n        \n        metrics: {\n          totalReach: userData.follower_count,\n          engagementRate: 0, // Will be calculated from content data\n          averageViews: 0,\n          averageLikes: 0,\n          averageComments: 0,\n          averageShares: 0,\n          growthRate: 0,\n          lastUpdated: new Date()\n        },\n        \n        syncSettings: {\n          autoSync: true,\n          syncFrequency: 'daily',\n          syncFields: ['profile', 'content', 'metrics'],\n          conflictResolution: 'latest',\n          privacyLevel: 'public'\n        }\n      };\n      \n      return connection;\n    } catch (error) {\n      console.error('TikTok authentication failed:', error);\n      throw new Error(`TikTok authentication failed: ${error.message}`);\n    }\n  }\n  \n  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {\n    try {\n      const tokens = this.decryptTokens({\n        accessToken: connection.accessToken,\n        refreshToken: connection.refreshToken\n      });\n      \n      const response = await this.apiClient.post('/oauth/refresh_token/', {\n        client_key: process.env.TIKTOK_CLIENT_KEY,\n        grant_type: 'refresh_token',\n        refresh_token: tokens.refresh\n      });\n      \n      const { access_token, refresh_token, expires_in } = response.data.data;\n      const encryptedTokens = this.encryptTokens({ access: access_token, refresh: refresh_token });\n      \n      return {\n        ...connection,\n        accessToken: encryptedTokens.accessToken,\n        refreshToken: encryptedTokens.refreshToken,\n        tokenExpiresAt: new Date(Date.now() + expires_in * 1000),\n        lastSyncAt: new Date()\n      };\n    } catch (error) {\n      console.error('TikTok token refresh failed:', error);\n      throw error;\n    }\n  }\n  \n  async fetchProfileData(connection: PlatformConnection): Promise<PlatformSpecificData> {\n    try {\n      const tokens = this.decryptTokens({\n        accessToken: connection.accessToken,\n        refreshToken: connection.refreshToken\n      });\n      \n      const response = await this.apiClient.get('/user/info/', {\n        headers: { Authorization: `Bearer ${tokens.access}` },\n        params: {\n          open_id: connection.userId,\n          fields: 'open_id,union_id,avatar_url,display_name,username,follower_count,following_count,likes_count'\n        }\n      });\n      \n      const userData = response.data.data.user;\n      \n      return {\n        tiktok: {\n          followerCount: userData.follower_count,\n          followingCount: userData.following_count,\n          likesCount: userData.likes_count,\n          videoCount: 0, // Updated in content fetch\n          verified: userData.verified || false,\n          bio: userData.bio || '',\n          avatarUrl: userData.avatar_url\n        }\n      };\n    } catch (error) {\n      console.error('TikTok profile fetch failed:', error);\n      throw error;\n    }\n  }\n  \n  async fetchContentData(connection: PlatformConnection, limit: number = 50): Promise<any[]> {\n    try {\n      const tokens = this.decryptTokens({\n        accessToken: connection.accessToken,\n        refreshToken: connection.refreshToken\n      });\n      \n      const response = await this.apiClient.post('/video/list/', {\n        open_id: connection.userId,\n        cursor: 0,\n        max_count: limit,\n        fields: 'id,create_time,cover_image_url,share_url,title,video_description,duration,view_count,like_count,comment_count,share_count'\n      }, {\n        headers: { Authorization: `Bearer ${tokens.access}` }\n      });\n      \n      return response.data.data.videos || [];\n    } catch (error) {\n      console.error('TikTok content fetch failed:', error);\n      return [];\n    }\n  }\n  \n  async calculateMetrics(profileData: PlatformSpecificData, contentData: any[]): Promise<PlatformMetrics> {\n    const tiktokData = profileData.tiktok!;\n    \n    if (contentData.length === 0) {\n      return {\n        totalReach: tiktokData.followerCount,\n        engagementRate: 0,\n        averageViews: 0,\n        averageLikes: 0,\n        averageComments: 0,\n        averageShares: 0,\n        growthRate: 0,\n        lastUpdated: new Date()\n      };\n    }\n    \n    // Calculate averages from content data\n    const totalViews = contentData.reduce((sum, video) => sum + (video.view_count || 0), 0);\n    const totalLikes = contentData.reduce((sum, video) => sum + (video.like_count || 0), 0);\n    const totalComments = contentData.reduce((sum, video) => sum + (video.comment_count || 0), 0);\n    const totalShares = contentData.reduce((sum, video) => sum + (video.share_count || 0), 0);\n    \n    const averageViews = totalViews / contentData.length;\n    const averageLikes = totalLikes / contentData.length;\n    const averageComments = totalComments / contentData.length;\n    const averageShares = totalShares / contentData.length;\n    \n    // Calculate engagement rate\n    const totalEngagements = totalLikes + totalComments + totalShares;\n    const engagementRate = totalViews > 0 ? (totalEngagements / totalViews) * 100 : 0;\n    \n    return {\n      totalReach: Math.max(tiktokData.followerCount, averageViews),\n      engagementRate: Math.round(engagementRate * 100) / 100,\n      averageViews: Math.round(averageViews),\n      averageLikes: Math.round(averageLikes),\n      averageComments: Math.round(averageComments),\n      averageShares: Math.round(averageShares),\n      growthRate: 0, // Would need historical data\n      lastUpdated: new Date()\n    };\n  }\n  \n  async validateConnection(connection: PlatformConnection): Promise<boolean> {\n    try {\n      // Check if token is expired\n      if (new Date() >= connection.tokenExpiresAt) {\n        return false;\n      }\n      \n      // Make a simple API call to validate\n      await this.fetchProfileData(connection);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n  \n  protected async authenticateRequest(config: any): Promise<any> {\n    // Add client key to all requests\n    if (!config.headers['Client-Key']) {\n      config.headers['Client-Key'] = process.env.TIKTOK_CLIENT_KEY;\n    }\n    return config;\n  }\n}\n\n/**\n * Instagram Platform Integration\n */\nexport class InstagramAdapter extends PlatformAdapter {\n  readonly platformId = 'instagram';\n  readonly apiVersion = 'v18.0';\n  \n  constructor() {\n    super('https://graph.facebook.com/v18.0');\n  }\n  \n  async authenticateUser(authCode: string, redirectUri: string): Promise<PlatformConnection> {\n    try {\n      // Step 1: Exchange code for access token\n      const tokenResponse = await this.apiClient.post('/oauth/access_token', {\n        client_id: process.env.INSTAGRAM_APP_ID,\n        client_secret: process.env.INSTAGRAM_APP_SECRET,\n        grant_type: 'authorization_code',\n        redirect_uri: redirectUri,\n        code: authCode\n      });\n      \n      const { access_token, user_id } = tokenResponse.data;\n      \n      // Step 2: Get long-lived token\n      const longTokenResponse = await this.apiClient.get('/oauth/access_token', {\n        params: {\n          grant_type: 'ig_exchange_token',\n          client_secret: process.env.INSTAGRAM_APP_SECRET,\n          access_token\n        }\n      });\n      \n      const longLivedToken = longTokenResponse.data.access_token;\n      const expiresIn = longTokenResponse.data.expires_in;\n      \n      // Step 3: Fetch user data\n      const userResponse = await this.apiClient.get(`/${user_id}`, {\n        params: {\n          fields: 'id,username,account_type,media_count,followers_count,follows_count',\n          access_token: longLivedToken\n        }\n      });\n      \n      const userData = userResponse.data;\n      \n      const connection: PlatformConnection = {\n        platformId: this.platformId,\n        username: userData.username,\n        userId: userData.id,\n        displayName: userData.username,\n        profileUrl: `https://instagram.com/${userData.username}`,\n        \n        connectionStatus: 'connected',\n        connectedAt: new Date(),\n        lastSyncAt: new Date(),\n        \n        accessToken: this.encryptTokens({ access: longLivedToken }).accessToken,\n        tokenExpiresAt: new Date(Date.now() + expiresIn * 1000),\n        \n        platformData: {\n          instagram: {\n            followerCount: userData.followers_count,\n            followingCount: userData.follows_count,\n            mediaCount: userData.media_count,\n            verified: false, // Instagram doesn't provide this in basic API\n            bio: '',\n            avatarUrl: '',\n            businessAccount: userData.account_type === 'BUSINESS'\n          }\n        },\n        \n        metrics: {\n          totalReach: userData.followers_count,\n          engagementRate: 0,\n          averageViews: 0,\n          averageLikes: 0,\n          averageComments: 0,\n          averageShares: 0,\n          growthRate: 0,\n          lastUpdated: new Date()\n        },\n        \n        syncSettings: {\n          autoSync: true,\n          syncFrequency: 'daily',\n          syncFields: ['profile', 'content', 'metrics'],\n          conflictResolution: 'latest',\n          privacyLevel: 'public'\n        }\n      };\n      \n      return connection;\n    } catch (error) {\n      console.error('Instagram authentication failed:', error);\n      throw new Error(`Instagram authentication failed: ${error.message}`);\n    }\n  }\n  \n  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {\n    try {\n      const tokens = this.decryptTokens({ accessToken: connection.accessToken });\n      \n      const response = await this.apiClient.get('/refresh_access_token', {\n        params: {\n          grant_type: 'ig_refresh_token',\n          access_token: tokens.access\n        }\n      });\n      \n      const { access_token, expires_in } = response.data;\n      const encryptedTokens = this.encryptTokens({ access: access_token });\n      \n      return {\n        ...connection,\n        accessToken: encryptedTokens.accessToken,\n        tokenExpiresAt: new Date(Date.now() + expires_in * 1000),\n        lastSyncAt: new Date()\n      };\n    } catch (error) {\n      console.error('Instagram token refresh failed:', error);\n      throw error;\n    }\n  }\n  \n  async fetchProfileData(connection: PlatformConnection): Promise<PlatformSpecificData> {\n    try {\n      const tokens = this.decryptTokens({ accessToken: connection.accessToken });\n      \n      const response = await this.apiClient.get(`/${connection.userId}`, {\n        params: {\n          fields: 'id,username,account_type,media_count,followers_count,follows_count',\n          access_token: tokens.access\n        }\n      });\n      \n      const userData = response.data;\n      \n      return {\n        instagram: {\n          followerCount: userData.followers_count,\n          followingCount: userData.follows_count,\n          mediaCount: userData.media_count,\n          verified: false,\n          bio: '',\n          avatarUrl: '',\n          businessAccount: userData.account_type === 'BUSINESS'\n        }\n      };\n    } catch (error) {\n      console.error('Instagram profile fetch failed:', error);\n      throw error;\n    }\n  }\n  \n  async fetchContentData(connection: PlatformConnection, limit: number = 50): Promise<any[]> {\n    try {\n      const tokens = this.decryptTokens({ accessToken: connection.accessToken });\n      \n      const response = await this.apiClient.get(`/${connection.userId}/media`, {\n        params: {\n          fields: 'id,media_type,media_url,permalink,caption,timestamp,like_count,comments_count',\n          limit,\n          access_token: tokens.access\n        }\n      });\n      \n      return response.data.data || [];\n    } catch (error) {\n      console.error('Instagram content fetch failed:', error);\n      return [];\n    }\n  }\n  \n  async calculateMetrics(profileData: PlatformSpecificData, contentData: any[]): Promise<PlatformMetrics> {\n    const instagramData = profileData.instagram!;\n    \n    if (contentData.length === 0) {\n      return {\n        totalReach: instagramData.followerCount,\n        engagementRate: 0,\n        averageViews: 0,\n        averageLikes: 0,\n        averageComments: 0,\n        averageShares: 0,\n        growthRate: 0,\n        lastUpdated: new Date()\n      };\n    }\n    \n    const totalLikes = contentData.reduce((sum, post) => sum + (post.like_count || 0), 0);\n    const totalComments = contentData.reduce((sum, post) => sum + (post.comments_count || 0), 0);\n    \n    const averageLikes = totalLikes / contentData.length;\n    const averageComments = totalComments / contentData.length;\n    \n    // Instagram engagement rate calculation\n    const engagementRate = instagramData.followerCount > 0 \n      ? ((averageLikes + averageComments) / instagramData.followerCount) * 100\n      : 0;\n    \n    return {\n      totalReach: instagramData.followerCount,\n      engagementRate: Math.round(engagementRate * 100) / 100,\n      averageViews: 0, // Instagram doesn't provide view counts in basic API\n      averageLikes: Math.round(averageLikes),\n      averageComments: Math.round(averageComments),\n      averageShares: 0, // Not available in Instagram API\n      growthRate: 0,\n      lastUpdated: new Date()\n    };\n  }\n  \n  async validateConnection(connection: PlatformConnection): Promise<boolean> {\n    try {\n      if (new Date() >= connection.tokenExpiresAt) {\n        return false;\n      }\n      \n      await this.fetchProfileData(connection);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}