// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\n\n/**\n * @title Content Licensing Contract\n * @dev NFT-based content licensing with royalties and usage tracking\n * @author Creative Identity Platform Team\n */\ncontract ContentLicensingContract is \n    ERC721URIStorage, \n    IERC2981, \n    Ownable, \n    ReentrancyGuard, \n    Pausable \n{\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _tokenIds;\n    \n    // Events\n    event ContentTokenized(uint256 indexed tokenId, address indexed creator, string contentHash);\n    event LicenseGranted(uint256 indexed tokenId, address indexed licensee, uint8 licenseType, uint256 price);\n    event LicenseRevoked(uint256 indexed tokenId, address indexed licensee, string reason);\n    event RoyaltyPaid(uint256 indexed tokenId, address indexed payer, uint256 amount);\n    event UsageReported(uint256 indexed tokenId, address indexed licensee, string platform, uint256 views);\n    event LicenseExpired(uint256 indexed tokenId, address indexed licensee);\n    \n    // Enums\n    enum LicenseType {\n        Personal,      // Personal use only\n        Commercial,    // Commercial use allowed\n        Editorial,     // Editorial/news use\n        Exclusive,     // Exclusive rights\n        Unlimited      // Unlimited usage rights\n    }\n    \n    enum LicenseStatus {\n        Active,\n        Expired,\n        Revoked,\n        Transferred\n    }\n    \n    // Structs\n    struct ContentMetadata {\n        string contentHash;     // IPFS hash of content\n        string creatorId;       // Universal Creative ID\n        uint256 creationDate;\n        string[] platforms;     // Original platforms\n        string contentType;     // image, video, audio, etc.\n        bool isAuthentic;\n        uint256 authenticityScore;\n    }\n    \n    struct LicenseTerms {\n        LicenseType licenseType;\n        uint256 price;           // Price in wei\n        uint256 duration;        // Duration in seconds (0 = perpetual)\n        uint256 maxUsage;        // Maximum usage count (0 = unlimited)\n        string[] allowedPlatforms; // Platforms where content can be used\n        bool transferable;       // Can license be transferred\n        uint256 royaltyPercentage; // Royalty percentage (basis points)\n    }\n    \n    struct License {\n        address licensee;\n        uint256 tokenId;\n        LicenseType licenseType;\n        uint256 grantedDate;\n        uint256 expirationDate;\n        uint256 usageCount;\n        uint256 maxUsage;\n        string[] allowedPlatforms;\n        LicenseStatus status;\n        bool transferable;\n    }\n    \n    struct UsageReport {\n        string platform;\n        uint256 timestamp;\n        uint256 views;\n        uint256 engagement;\n        string reporterAddress;\n    }\n    \n    // State variables\n    mapping(uint256 => ContentMetadata) public contentMetadata;\n    mapping(uint256 => LicenseTerms) public defaultLicenseTerms;\n    mapping(uint256 => mapping(address => License)) public licenses;\n    mapping(uint256 => address[]) public licensees;\n    mapping(uint256 => UsageReport[]) public usageReports;\n    mapping(address => uint256[]) public creatorTokens;\n    mapping(uint256 => uint256) public totalRoyaltiesPaid;\n    \n    // Platform fee (basis points - 250 = 2.5%)\n    uint256 public constant PLATFORM_FEE = 250;\n    uint256 public constant BASIS_POINTS = 10000;\n    \n    // Royalty info for ERC2981\n    mapping(uint256 => address) private _royaltyRecipients;\n    mapping(uint256 => uint256) private _royaltyPercentages;\n    \n    constructor() ERC721(\"Creative Content License\", \"CCL\") {}\n    \n    /**\n     * @dev Tokenize content and set licensing terms\n     * @param _contentHash IPFS hash of the content\n     * @param _creatorId Universal Creative ID\n     * @param _contentType Type of content\n     * @param _platforms Original platforms\n     * @param _licenseTerms Default license terms\n     * @param _tokenURI Metadata URI for the NFT\n     */\n    function tokenizeContent(\n        string memory _contentHash,\n        string memory _creatorId,\n        string memory _contentType,\n        string[] memory _platforms,\n        LicenseTerms memory _licenseTerms,\n        string memory _tokenURI\n    ) external whenNotPaused returns (uint256) {\n        require(bytes(_contentHash).length > 0, \"Content hash required\");\n        require(bytes(_creatorId).length > 0, \"Creator ID required\");\n        require(_licenseTerms.royaltyPercentage <= 5000, \"Royalty too high\"); // Max 50%\n        \n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n        \n        // Mint NFT to creator\n        _safeMint(msg.sender, newTokenId);\n        _setTokenURI(newTokenId, _tokenURI);\n        \n        // Set content metadata\n        contentMetadata[newTokenId] = ContentMetadata({\n            contentHash: _contentHash,\n            creatorId: _creatorId,\n            creationDate: block.timestamp,\n            platforms: _platforms,\n            contentType: _contentType,\n            isAuthentic: true, // Verified through Creative Identity Registry\n            authenticityScore: 95 // Would be fetched from registry\n        });\n        \n        // Set default license terms\n        defaultLicenseTerms[newTokenId] = _licenseTerms;\n        \n        // Set royalty info\n        _royaltyRecipients[newTokenId] = msg.sender;\n        _royaltyPercentages[newTokenId] = _licenseTerms.royaltyPercentage;\n        \n        // Track creator's tokens\n        creatorTokens[msg.sender].push(newTokenId);\n        \n        emit ContentTokenized(newTokenId, msg.sender, _contentHash);\n        \n        return newTokenId;\n    }\n    \n    /**\n     * @dev Purchase license for content usage\n     * @param _tokenId Token ID of the content\n     * @param _licenseType Type of license to purchase\n     * @param _duration Custom duration (if applicable)\n     * @param _platforms Custom platforms (if applicable)\n     */\n    function purchaseLicense(\n        uint256 _tokenId,\n        LicenseType _licenseType,\n        uint256 _duration,\n        string[] memory _platforms\n    ) external payable nonReentrant whenNotPaused {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(msg.sender != ownerOf(_tokenId), \"Creator cannot license own content\");\n        require(licenses[_tokenId][msg.sender].status != LicenseStatus.Active, \"Active license exists\");\n        \n        LicenseTerms memory terms = defaultLicenseTerms[_tokenId];\n        \n        // Calculate price based on license type and customizations\n        uint256 licensePrice = _calculateLicensePrice(_tokenId, _licenseType, _duration, _platforms);\n        require(msg.value >= licensePrice, \"Insufficient payment\");\n        \n        // Set license duration (use custom or default)\n        uint256 duration = _duration > 0 ? _duration : terms.duration;\n        uint256 expirationDate = duration > 0 ? block.timestamp + duration : 0; // 0 = perpetual\n        \n        // Set allowed platforms (use custom or default)\n        string[] memory allowedPlatforms = _platforms.length > 0 ? _platforms : terms.allowedPlatforms;\n        \n        // Create license\n        licenses[_tokenId][msg.sender] = License({\n            licensee: msg.sender,\n            tokenId: _tokenId,\n            licenseType: _licenseType,\n            grantedDate: block.timestamp,\n            expirationDate: expirationDate,\n            usageCount: 0,\n            maxUsage: terms.maxUsage,\n            allowedPlatforms: allowedPlatforms,\n            status: LicenseStatus.Active,\n            transferable: terms.transferable\n        });\n        \n        // Add to licensees list\n        licensees[_tokenId].push(msg.sender);\n        \n        // Distribute payment\n        _distributeLicensePayment(_tokenId, licensePrice);\n        \n        // Refund excess payment\n        if (msg.value > licensePrice) {\n            payable(msg.sender).transfer(msg.value - licensePrice);\n        }\n        \n        emit LicenseGranted(_tokenId, msg.sender, uint8(_licenseType), licensePrice);\n    }\n    \n    /**\n     * @dev Report content usage for tracking and royalty calculation\n     * @param _tokenId Token ID of the content\n     * @param _platform Platform where content was used\n     * @param _views Number of views/impressions\n     * @param _engagement Engagement metrics\n     */\n    function reportUsage(\n        uint256 _tokenId,\n        string memory _platform,\n        uint256 _views,\n        uint256 _engagement\n    ) external whenNotPaused {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(licenses[_tokenId][msg.sender].status == LicenseStatus.Active, \"No active license\");\n        \n        License storage license = licenses[_tokenId][msg.sender];\n        \n        // Check if platform is allowed\n        bool platformAllowed = false;\n        for (uint i = 0; i < license.allowedPlatforms.length; i++) {\n            if (keccak256(bytes(license.allowedPlatforms[i])) == keccak256(bytes(_platform))) {\n                platformAllowed = true;\n                break;\n            }\n        }\n        require(platformAllowed, \"Platform not allowed\");\n        \n        // Check usage limits\n        if (license.maxUsage > 0) {\n            require(license.usageCount < license.maxUsage, \"Usage limit exceeded\");\n        }\n        \n        // Check expiration\n        if (license.expirationDate > 0) {\n            require(block.timestamp <= license.expirationDate, \"License expired\");\n        }\n        \n        // Record usage\n        usageReports[_tokenId].push(UsageReport({\n            platform: _platform,\n            timestamp: block.timestamp,\n            views: _views,\n            engagement: _engagement,\n            reporterAddress: Strings.toHexString(uint160(msg.sender), 20)\n        }));\n        \n        // Increment usage count\n        license.usageCount++;\n        \n        emit UsageReported(_tokenId, msg.sender, _platform, _views);\n        \n        // Auto-revoke if max usage reached\n        if (license.maxUsage > 0 && license.usageCount >= license.maxUsage) {\n            license.status = LicenseStatus.Expired;\n            emit LicenseExpired(_tokenId, msg.sender);\n        }\n    }\n    \n    /**\n     * @dev Revoke license (only by content owner)\n     * @param _tokenId Token ID\n     * @param _licensee Address of licensee\n     * @param _reason Reason for revocation\n     */\n    function revokeLicense(\n        uint256 _tokenId,\n        address _licensee,\n        string memory _reason\n    ) external whenNotPaused {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(msg.sender == ownerOf(_tokenId), \"Only content owner can revoke\");\n        require(licenses[_tokenId][_licensee].status == LicenseStatus.Active, \"License not active\");\n        \n        licenses[_tokenId][_licensee].status = LicenseStatus.Revoked;\n        \n        emit LicenseRevoked(_tokenId, _licensee, _reason);\n    }\n    \n    /**\n     * @dev Transfer license to another address (if transferable)\n     * @param _tokenId Token ID\n     * @param _newLicensee New licensee address\n     */\n    function transferLicense(\n        uint256 _tokenId,\n        address _newLicensee\n    ) external whenNotPaused {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(licenses[_tokenId][msg.sender].status == LicenseStatus.Active, \"No active license\");\n        require(licenses[_tokenId][msg.sender].transferable, \"License not transferable\");\n        require(_newLicensee != address(0), \"Invalid new licensee\");\n        require(licenses[_tokenId][_newLicensee].status != LicenseStatus.Active, \"Target has active license\");\n        \n        // Transfer license\n        License memory oldLicense = licenses[_tokenId][msg.sender];\n        oldLicense.licensee = _newLicensee;\n        oldLicense.status = LicenseStatus.Transferred;\n        \n        licenses[_tokenId][_newLicensee] = oldLicense;\n        licenses[_tokenId][msg.sender].status = LicenseStatus.Transferred;\n        \n        // Update licensees list\n        licensees[_tokenId].push(_newLicensee);\n    }\n    \n    /**\n     * @dev Pay royalty for content usage\n     * @param _tokenId Token ID\n     */\n    function payRoyalty(uint256 _tokenId) external payable nonReentrant {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(msg.value > 0, \"No payment provided\");\n        \n        address creator = ownerOf(_tokenId);\n        uint256 platformFee = (msg.value * PLATFORM_FEE) / BASIS_POINTS;\n        uint256 creatorPayment = msg.value - platformFee;\n        \n        // Transfer to creator\n        payable(creator).transfer(creatorPayment);\n        \n        // Track total royalties\n        totalRoyaltiesPaid[_tokenId] += creatorPayment;\n        \n        emit RoyaltyPaid(_tokenId, msg.sender, creatorPayment);\n    }\n    \n    // View functions\n    \n    /**\n     * @dev Get license information\n     * @param _tokenId Token ID\n     * @param _licensee Licensee address\n     * @return License struct\n     */\n    function getLicense(uint256 _tokenId, address _licensee) external view returns (License memory) {\n        return licenses[_tokenId][_licensee];\n    }\n    \n    /**\n     * @dev Get all licensees for a token\n     * @param _tokenId Token ID\n     * @return Array of licensee addresses\n     */\n    function getTokenLicensees(uint256 _tokenId) external view returns (address[] memory) {\n        return licensees[_tokenId];\n    }\n    \n    /**\n     * @dev Get usage reports for a token\n     * @param _tokenId Token ID\n     * @return Array of usage reports\n     */\n    function getUsageReports(uint256 _tokenId) external view returns (UsageReport[] memory) {\n        return usageReports[_tokenId];\n    }\n    \n    /**\n     * @dev Get creator's tokens\n     * @param _creator Creator address\n     * @return Array of token IDs\n     */\n    function getCreatorTokens(address _creator) external view returns (uint256[] memory) {\n        return creatorTokens[_creator];\n    }\n    \n    /**\n     * @dev Check if license is active and valid\n     * @param _tokenId Token ID\n     * @param _licensee Licensee address\n     * @return Whether license is active\n     */\n    function isLicenseActive(uint256 _tokenId, address _licensee) external view returns (bool) {\n        License memory license = licenses[_tokenId][_licensee];\n        \n        if (license.status != LicenseStatus.Active) {\n            return false;\n        }\n        \n        // Check expiration\n        if (license.expirationDate > 0 && block.timestamp > license.expirationDate) {\n            return false;\n        }\n        \n        // Check usage limits\n        if (license.maxUsage > 0 && license.usageCount >= license.maxUsage) {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    // ERC2981 Royalty Info\n    \n    /**\n     * @dev Returns royalty info for ERC2981 compatibility\n     * @param _tokenId Token ID\n     * @param _salePrice Sale price\n     * @return receiver Royalty recipient\n     * @return royaltyAmount Royalty amount\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) \n        external \n        view \n        override \n        returns (address receiver, uint256 royaltyAmount) \n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        \n        address recipient = _royaltyRecipients[_tokenId];\n        uint256 percentage = _royaltyPercentages[_tokenId];\n        uint256 royalty = (_salePrice * percentage) / BASIS_POINTS;\n        \n        return (recipient, royalty);\n    }\n    \n    /**\n     * @dev Set royalty info (only token owner)\n     * @param _tokenId Token ID\n     * @param _recipient Royalty recipient\n     * @param _percentage Royalty percentage (basis points)\n     */\n    function setRoyaltyInfo(\n        uint256 _tokenId,\n        address _recipient,\n        uint256 _percentage\n    ) external {\n        require(_exists(_tokenId), \"Token does not exist\");\n        require(msg.sender == ownerOf(_tokenId), \"Only token owner\");\n        require(_percentage <= 5000, \"Royalty too high\"); // Max 50%\n        \n        _royaltyRecipients[_tokenId] = _recipient;\n        _royaltyPercentages[_tokenId] = _percentage;\n    }\n    \n    // Admin functions\n    \n    /**\n     * @dev Update content authenticity (only owner)\n     * @param _tokenId Token ID\n     * @param _isAuthentic Authenticity status\n     * @param _score Authenticity score\n     */\n    function updateContentAuthenticity(\n        uint256 _tokenId,\n        bool _isAuthentic,\n        uint256 _score\n    ) external onlyOwner {\n        require(_exists(_tokenId), \"Token does not exist\");\n        \n        contentMetadata[_tokenId].isAuthentic = _isAuthentic;\n        contentMetadata[_tokenId].authenticityScore = _score;\n    }\n    \n    /**\n     * @dev Pause contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpause contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    /**\n     * @dev Withdraw platform fees\n     */\n    function withdrawFees() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    // Private functions\n    \n    /**\n     * @dev Calculate license price based on parameters\n     * @param _tokenId Token ID\n     * @param _licenseType License type\n     * @param _duration Custom duration\n     * @param _platforms Custom platforms\n     * @return License price\n     */\n    function _calculateLicensePrice(\n        uint256 _tokenId,\n        LicenseType _licenseType,\n        uint256 _duration,\n        string[] memory _platforms\n    ) private view returns (uint256) {\n        LicenseTerms memory terms = defaultLicenseTerms[_tokenId];\n        uint256 basePrice = terms.price;\n        \n        // Price multipliers based on license type\n        if (_licenseType == LicenseType.Commercial) {\n            basePrice = basePrice * 3; // 3x for commercial\n        } else if (_licenseType == LicenseType.Exclusive) {\n            basePrice = basePrice * 10; // 10x for exclusive\n        } else if (_licenseType == LicenseType.Unlimited) {\n            basePrice = basePrice * 20; // 20x for unlimited\n        }\n        \n        // Duration multiplier (if custom duration is longer)\n        if (_duration > terms.duration && terms.duration > 0) {\n            uint256 durationMultiplier = _duration / terms.duration;\n            basePrice = basePrice * durationMultiplier;\n        }\n        \n        // Platform multiplier (more platforms = higher price)\n        if (_platforms.length > terms.allowedPlatforms.length) {\n            uint256 platformMultiplier = _platforms.length / terms.allowedPlatforms.length;\n            basePrice = basePrice * platformMultiplier;\n        }\n        \n        return basePrice;\n    }\n    \n    /**\n     * @dev Distribute license payment between creator and platform\n     * @param _tokenId Token ID\n     * @param _amount Payment amount\n     */\n    function _distributeLicensePayment(uint256 _tokenId, uint256 _amount) private {\n        address creator = ownerOf(_tokenId);\n        uint256 platformFee = (_amount * PLATFORM_FEE) / BASIS_POINTS;\n        uint256 creatorPayment = _amount - platformFee;\n        \n        // Transfer to creator\n        payable(creator).transfer(creatorPayment);\n        // Platform fee stays in contract\n    }\n    \n    // Required overrides\n    \n    function supportsInterface(bytes4 interfaceId) \n        public \n        view \n        override(ERC721URIStorage, IERC165) \n        returns (bool) \n    {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n}