import { CreativeIdentity } from '../CreativeIdentity';\nimport { BiometricVerifier } from '../BiometricVerifier';\nimport { StoryProtocolClient } from '../StoryProtocolClient';\nimport { CreateIdentityRequest, VerificationMethod } from '@/types/identity';\n\n// Mock dependencies\njest.mock('../BiometricVerifier');\njest.mock('../StoryProtocolClient');\njest.mock('../ContentAuthenticator');\n\ndescribe('CreativeIdentity', () => {\n  let creativeIdentity: CreativeIdentity;\n  let mockBiometricVerifier: jest.Mocked<BiometricVerifier>;\n  let mockStoryClient: jest.Mocked<StoryProtocolClient>;\n  \n  const mockPrivateKey = '0x1234567890123456789012345678901234567890123456789012345678901234';\n  const mockRpcUrl = 'http://localhost:8545';\n  const mockStoryConfig = { apiUrl: 'http://localhost:3000' };\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    // Setup mocks\n    mockBiometricVerifier = new BiometricVerifier() as jest.Mocked<BiometricVerifier>;\n    mockStoryClient = new StoryProtocolClient(mockStoryConfig) as jest.Mocked<StoryProtocolClient>;\n    \n    creativeIdentity = new CreativeIdentity(\n      mockPrivateKey,\n      mockRpcUrl,\n      mockStoryConfig\n    );\n    \n    // Mock successful biometric verification\n    mockBiometricVerifier.verifyBiometric.mockResolvedValue({\n      confidence: 0.95,\n      isAuthentic: true,\n      riskFactors: []\n    });\n    \n    // Mock Story Protocol registration\n    mockStoryClient.registerCreator.mockResolvedValue({\n      id: 'story_123',\n      transactionHash: '0xstoryhash'\n    });\n  });\n  \n  describe('createIdentity', () => {\n    const mockRequest: CreateIdentityRequest = {\n      biometricData: {\n        type: 'face',\n        encodedData: 'base64encodedface',\n        confidence: 0.95,\n        capturedAt: new Date(),\n        deviceInfo: {\n          deviceId: 'test-device',\n          platform: 'web',\n          osVersion: '10.0',\n          appVersion: '1.0.0',\n          securityLevel: 'high'\n        }\n      },\n      walletAddress: '0x1234567890123456789012345678901234567890',\n      privacySettings: {\n        publicProfile: true,\n        shareMetrics: true,\n        allowDiscovery: true,\n        dataRetention: 365,\n        crossPlatformSync: true,\n        biometricDataSharing: false\n      }\n    };\n    \n    it('should create a new creative identity successfully', async () => {\n      const result = await creativeIdentity.createIdentity(mockRequest);\n      \n      expect(result).toBeDefined();\n      expect(result.identity).toBeDefined();\n      expect(result.identity.id).toHaveValidUniversalCreativeID();\n      expect(result.identity.walletAddress).toBeValidEthereumAddress();\n      expect(result.identity.verificationLevel).toBe(10);\n      expect(result.identity.status).toBe('pending');\n      expect(result.blockchain.transactionHash).toBeDefined();\n      expect(result.blockchain.contractAddress).toBeValidEthereumAddress();\n      expect(result.qrCode).toBeDefined();\n      expect(result.backupCodes).toHaveLength(10);\n    }, 30000);\n    \n    it('should reject identity creation with low biometric confidence', async () => {\n      mockBiometricVerifier.verifyBiometric.mockResolvedValueOnce({\n        confidence: 0.8,\n        isAuthentic: false,\n        riskFactors: ['low_quality_image']\n      });\n      \n      await expect(creativeIdentity.createIdentity(mockRequest))\n        .rejects\n        .toThrow('Biometric verification failed - insufficient confidence');\n      \n      expect(mockBiometricVerifier.verifyBiometric).toHaveBeenCalledWith(mockRequest.biometricData);\n    });\n    \n    it('should generate unique identity IDs for multiple creators', async () => {\n      const request1 = { ...mockRequest };\n      const request2 = {\n        ...mockRequest,\n        biometricData: {\n          ...mockRequest.biometricData,\n          encodedData: 'different_encoded_data'\n        },\n        walletAddress: '0x9876543210987654321098765432109876543210'\n      };\n      \n      const [result1, result2] = await Promise.all([\n        creativeIdentity.createIdentity(request1),\n        creativeIdentity.createIdentity(request2)\n      ]);\n      \n      expect(result1.identity.id).not.toBe(result2.identity.id);\n      expect(result1.identity.walletAddress).not.toBe(result2.identity.walletAddress);\n    });\n    \n    it('should include biometric verification method in identity', async () => {\n      const result = await creativeIdentity.createIdentity(mockRequest);\n      \n      const biometricVerification = result.identity.verificationMethods.find(\n        method => method.type === 'biometric'\n      );\n      \n      expect(biometricVerification).toBeDefined();\n      expect(biometricVerification?.status).toBe('verified');\n      expect(biometricVerification?.confidence).toBe(0.95);\n      expect(biometricVerification?.metadata.method).toBe('face');\n    });\n    \n    it('should connect initial platforms if provided', async () => {\n      const requestWithPlatforms = {\n        ...mockRequest,\n        initialPlatforms: [{\n          platformId: 'tiktok',\n          authorizationCode: 'auth_code_123',\n          redirectUri: 'http://localhost:3000/callback'\n        }]\n      };\n      \n      // Mock successful platform connection\n      jest.spyOn(creativeIdentity as any, 'connectPlatform')\n        .mockResolvedValueOnce(createMockPlatformConnection('tiktok'));\n      \n      const result = await creativeIdentity.createIdentity(requestWithPlatforms);\n      \n      expect(result.identity.connectedPlatforms.size).toBe(1);\n      expect(result.identity.connectedPlatforms.has('tiktok')).toBe(true);\n      expect(result.identity.verificationLevel).toBe(20); // Base 10 + platform 10\n    });\n  });\n  \n  describe('verifyContentAuthenticity', () => {\n    const mockContentData = Buffer.from('test content data');\n    const mockContentType = 'image';\n    const mockPlatformOrigin = 'tiktok';\n    const mockCreatorId = 'uci_test123456789';\n    \n    beforeEach(() => {\n      // Mock content authentication\n      const mockContentAuth = {\n        verifyAuthenticity: jest.fn().mockResolvedValue({\n          overallScore: 95,\n          riskLevel: 'low',\n          biometricMatch: 0.95,\n          metadataConsistency: 0.9,\n          deepfakeDetection: { isDeepfake: false, confidence: 0.95 },\n          socialProof: { platformVerification: true },\n          blockchainProof: { transactionHash: '0xproof123' }\n        }),\n        generateC2PAManifest: jest.fn().mockResolvedValue({\n          version: '1.0',\n          claim: {\n            generator: 'Creative Identity Platform',\n            created: new Date().toISOString(),\n            credentials: [],\n            assertions: []\n          },\n          signature: 'signature_123'\n        })\n      };\n      \n      (creativeIdentity as any).contentAuth = mockContentAuth;\n    });\n    \n    it('should verify content authenticity successfully', async () => {\n      const result = await creativeIdentity.verifyContentAuthenticity(\n        mockCreatorId,\n        mockContentData,\n        mockContentType,\n        mockPlatformOrigin\n      );\n      \n      expect(result).toBeDefined();\n      expect(result.contentHash).toMatch(/^[a-f0-9]{64}$/);\n      expect(result.creatorId).toBe(mockCreatorId);\n      expect(result.contentType).toBe(mockContentType);\n      expect(result.originalPlatform).toBe(mockPlatformOrigin);\n      expect(result.verificationStatus).toBe('verified');\n      expect(result.authenticityProof.overallScore).toBe(95);\n      expect(result.blockchainTxHash).toBeDefined();\n      expect(result.ipfsHash).toBeValidIPFSHash();\n    }, 30000);\n    \n    it('should mark content as pending for low authenticity score', async () => {\n      const mockContentAuth = (creativeIdentity as any).contentAuth;\n      mockContentAuth.verifyAuthenticity.mockResolvedValueOnce({\n        overallScore: 75,\n        riskLevel: 'medium',\n        biometricMatch: 0.8,\n        metadataConsistency: 0.7,\n        deepfakeDetection: { isDeepfake: false, confidence: 0.75 },\n        socialProof: { platformVerification: false },\n        blockchainProof: { transactionHash: '0xproof456' }\n      });\n      \n      const result = await creativeIdentity.verifyContentAuthenticity(\n        mockCreatorId,\n        mockContentData,\n        mockContentType,\n        mockPlatformOrigin\n      );\n      \n      expect(result.verificationStatus).toBe('pending');\n      expect(result.authenticityProof.overallScore).toBe(75);\n    });\n    \n    it('should generate unique content hashes for different content', async () => {\n      const content1 = Buffer.from('content 1');\n      const content2 = Buffer.from('content 2');\n      \n      const [result1, result2] = await Promise.all([\n        creativeIdentity.verifyContentAuthenticity(mockCreatorId, content1, mockContentType, mockPlatformOrigin),\n        creativeIdentity.verifyContentAuthenticity(mockCreatorId, content2, mockContentType, mockPlatformOrigin)\n      ]);\n      \n      expect(result1.contentHash).not.toBe(result2.contentHash);\n      expect(result1.id).not.toBe(result2.id);\n    });\n  });\n  \n  describe('updateVerificationLevel', () => {\n    const mockIdentityId = 'uci_test123456789';\n    \n    beforeEach(() => {\n      // Mock identity retrieval\n      jest.spyOn(creativeIdentity as any, 'getIdentity')\n        .mockResolvedValue(createMockCreator());\n      \n      // Mock identity storage\n      jest.spyOn(creativeIdentity as any, 'storeIdentity')\n        .mockResolvedValue(undefined);\n      \n      // Mock blockchain update\n      jest.spyOn(creativeIdentity as any, 'updateIdentityOnChain')\n        .mockResolvedValue(undefined);\n    });\n    \n    it('should update verification level with new verification method', async () => {\n      const newVerification: VerificationMethod = {\n        type: 'government_id',\n        status: 'verified',\n        verifiedAt: new Date(),\n        confidence: 0.98,\n        metadata: {\n          documentType: 'passport',\n          issuingCountry: 'US'\n        }\n      };\n      \n      const result = await creativeIdentity.updateVerificationLevel(\n        mockIdentityId,\n        newVerification\n      );\n      \n      expect(result).toBeGreaterThan(85); // Should increase from base level\n      expect(result).toBeLessThanOrEqual(100);\n    });\n    \n    it('should trigger blockchain update for significant level changes', async () => {\n      const mockUpdateIdentityOnChain = jest.spyOn(creativeIdentity as any, 'updateIdentityOnChain');\n      \n      const significantVerification: VerificationMethod = {\n        type: 'platform_verification',\n        status: 'verified',\n        verifiedAt: new Date(),\n        confidence: 1.0,\n        metadata: {\n          platform: 'tiktok',\n          followerCount: 100000\n        }\n      };\n      \n      await creativeIdentity.updateVerificationLevel(\n        mockIdentityId,\n        significantVerification\n      );\n      \n      expect(mockUpdateIdentityOnChain).toHaveBeenCalledWith(\n        mockIdentityId,\n        expect.objectContaining({\n          verificationLevel: expect.any(Number),\n          lastUpdated: expect.any(Date)\n        })\n      );\n    });\n    \n    it('should handle multiple verification methods correctly', async () => {\n      const mockIdentity = createMockCreator();\n      mockIdentity.verificationMethods = [\n        {\n          type: 'biometric',\n          status: 'verified',\n          verifiedAt: new Date(),\n          confidence: 0.95,\n          metadata: {}\n        },\n        {\n          type: 'platform_verification',\n          status: 'verified',\n          verifiedAt: new Date(),\n          confidence: 0.9,\n          metadata: {}\n        }\n      ];\n      \n      jest.spyOn(creativeIdentity as any, 'getIdentity')\n        .mockResolvedValue(mockIdentity);\n      \n      const newVerification: VerificationMethod = {\n        type: 'community_vouching',\n        status: 'verified',\n        verifiedAt: new Date(),\n        confidence: 0.85,\n        metadata: {\n          vouchCount: 10,\n          averageRating: 4.8\n        }\n      };\n      \n      const result = await creativeIdentity.updateVerificationLevel(\n        mockIdentityId,\n        newVerification\n      );\n      \n      // Should calculate cumulative score from all verification methods\n      expect(result).toBeGreaterThan(50); // Should be higher with multiple verifications\n    });\n  });\n  \n  describe('generateUniversalID', () => {\n    it('should generate consistent IDs for same input', () => {\n      const biometricData = {\n        type: 'face' as const,\n        encodedData: 'test_encoded_data',\n        confidence: 0.95,\n        capturedAt: new Date(),\n        deviceInfo: {\n          deviceId: 'test-device',\n          platform: 'web',\n          osVersion: '10.0',\n          appVersion: '1.0.0',\n          securityLevel: 'high' as const\n        }\n      };\n      const walletAddress = '0x1234567890123456789012345678901234567890';\n      \n      // Mock Date.now to get consistent results\n      const mockTime = 1640995200000; // Fixed timestamp\n      jest.spyOn(Date, 'now').mockReturnValue(mockTime);\n      \n      const id1 = (creativeIdentity as any).generateUniversalID(biometricData, walletAddress);\n      const id2 = (creativeIdentity as any).generateUniversalID(biometricData, walletAddress);\n      \n      expect(id1).toBe(id2);\n      expect(id1).toHaveValidUniversalCreativeID();\n      \n      Date.now.mockRestore();\n    });\n    \n    it('should generate different IDs for different inputs', () => {\n      const biometricData1 = {\n        type: 'face' as const,\n        encodedData: 'test_encoded_data_1',\n        confidence: 0.95,\n        capturedAt: new Date(),\n        deviceInfo: {\n          deviceId: 'test-device-1',\n          platform: 'web',\n          osVersion: '10.0',\n          appVersion: '1.0.0',\n          securityLevel: 'high' as const\n        }\n      };\n      \n      const biometricData2 = {\n        type: 'face' as const,\n        encodedData: 'test_encoded_data_2',\n        confidence: 0.95,\n        capturedAt: new Date(),\n        deviceInfo: {\n          deviceId: 'test-device-2',\n          platform: 'web',\n          osVersion: '10.0',\n          appVersion: '1.0.0',\n          securityLevel: 'high' as const\n        }\n      };\n      \n      const walletAddress = '0x1234567890123456789012345678901234567890';\n      \n      const id1 = (creativeIdentity as any).generateUniversalID(biometricData1, walletAddress);\n      const id2 = (creativeIdentity as any).generateUniversalID(biometricData2, walletAddress);\n      \n      expect(id1).not.toBe(id2);\n      expect(id1).toHaveValidUniversalCreativeID();\n      expect(id2).toHaveValidUniversalCreativeID();\n    });\n  });\n  \n  describe('error handling', () => {\n    it('should handle Story Protocol registration failure', async () => {\n      mockStoryClient.registerCreator.mockRejectedValueOnce(\n        new Error('Story Protocol registration failed')\n      );\n      \n      const mockRequest: CreateIdentityRequest = {\n        biometricData: {\n          type: 'face',\n          encodedData: 'base64encodedface',\n          confidence: 0.95,\n          capturedAt: new Date(),\n          deviceInfo: {\n            deviceId: 'test-device',\n            platform: 'web',\n            osVersion: '10.0',\n            appVersion: '1.0.0',\n            securityLevel: 'high'\n          }\n        },\n        walletAddress: '0x1234567890123456789012345678901234567890',\n        privacySettings: {\n          publicProfile: true,\n          shareMetrics: true,\n          allowDiscovery: true,\n          dataRetention: 365,\n          crossPlatformSync: true,\n          biometricDataSharing: false\n        }\n      };\n      \n      await expect(creativeIdentity.createIdentity(mockRequest))\n        .rejects\n        .toThrow('Failed to create identity');\n    });\n    \n    it('should handle blockchain deployment failure gracefully', async () => {\n      jest.spyOn(creativeIdentity as any, 'deployIdentityContract')\n        .mockRejectedValueOnce(new Error('Blockchain deployment failed'));\n      \n      const mockRequest: CreateIdentityRequest = {\n        biometricData: {\n          type: 'face',\n          encodedData: 'base64encodedface',\n          confidence: 0.95,\n          capturedAt: new Date(),\n          deviceInfo: {\n            deviceId: 'test-device',\n            platform: 'web',\n            osVersion: '10.0',\n            appVersion: '1.0.0',\n            securityLevel: 'high'\n          }\n        },\n        walletAddress: '0x1234567890123456789012345678901234567890',\n        privacySettings: {\n          publicProfile: true,\n          shareMetrics: true,\n          allowDiscovery: true,\n          dataRetention: 365,\n          crossPlatformSync: true,\n          biometricDataSharing: false\n        }\n      };\n      \n      await expect(creativeIdentity.createIdentity(mockRequest))\n        .rejects\n        .toThrow('Failed to create identity: Blockchain deployment failed');\n    });\n  });\n  \n  describe('performance tests', () => {\n    it('should create identity within performance threshold', async () => {\n      const mockRequest: CreateIdentityRequest = {\n        biometricData: {\n          type: 'face',\n          encodedData: 'base64encodedface',\n          confidence: 0.95,\n          capturedAt: new Date(),\n          deviceInfo: {\n            deviceId: 'test-device',\n            platform: 'web',\n            osVersion: '10.0',\n            appVersion: '1.0.0',\n            securityLevel: 'high'\n          }\n        },\n        walletAddress: '0x1234567890123456789012345678901234567890',\n        privacySettings: {\n          publicProfile: true,\n          shareMetrics: true,\n          allowDiscovery: true,\n          dataRetention: 365,\n          crossPlatformSync: true,\n          biometricDataSharing: false\n        }\n      };\n      \n      const { result, executionTime } = await measureExecutionTime(() => \n        creativeIdentity.createIdentity(mockRequest)\n      );\n      \n      expect(result).toBeDefined();\n      expect(executionTime).toBeLessThan(3000); // Should complete within 3 seconds\n    });\n    \n    it('should handle concurrent identity creation', async () => {\n      const requests = Array.from({ length: 10 }, (_, i) => ({\n        biometricData: {\n          type: 'face' as const,\n          encodedData: `base64encodedface${i}`,\n          confidence: 0.95,\n          capturedAt: new Date(),\n          deviceInfo: {\n            deviceId: `test-device-${i}`,\n            platform: 'web',\n            osVersion: '10.0',\n            appVersion: '1.0.0',\n            securityLevel: 'high' as const\n          }\n        },\n        walletAddress: `0x${i.toString().padStart(40, '0')}`,\n        privacySettings: {\n          publicProfile: true,\n          shareMetrics: true,\n          allowDiscovery: true,\n          dataRetention: 365,\n          crossPlatformSync: true,\n          biometricDataSharing: false\n        }\n      }));\n      \n      const { result: results, executionTime } = await measureExecutionTime(() => \n        Promise.all(requests.map(req => creativeIdentity.createIdentity(req)))\n      );\n      \n      expect(results).toHaveLength(10);\n      expect(executionTime).toBeLessThan(10000); // Should complete within 10 seconds\n      \n      // Verify all IDs are unique\n      const ids = results.map(r => r.identity.id);\n      expect(new Set(ids).size).toBe(10);\n    });\n  });\n});"