// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @title Creative Identity Registry\n * @dev Smart contract for managing universal creative identities with authenticity verification\n * @author Creative Identity Platform Team\n */\ncontract CreativeIdentityRegistry is Ownable, ReentrancyGuard, Pausable {\n    using ECDSA for bytes32;\n    using Counters for Counters.Counter;\n    \n    // Counter for identity IDs\n    Counters.Counter private _identityIds;\n    \n    // Events\n    event IdentityRegistered(address indexed creator, uint256 indexed identityId, string identityHash);\n    event IdentityVerified(address indexed creator, uint256 indexed identityId, uint8 verificationLevel);\n    event PlatformConnected(address indexed creator, uint256 indexed identityId, string platform);\n    event ContentProofAdded(address indexed creator, uint256 indexed identityId, bytes32 contentHash);\n    event VerificationChallenged(bytes32 indexed contentHash, address challenger, uint256 stake);\n    event IdentityUpdated(address indexed creator, uint256 indexed identityId, string newHash);\n    \n    // Structs\n    struct CreatorIdentity {\n        address walletAddress;\n        string identityHash; // IPFS hash of identity metadata\n        uint8 verificationLevel; // 0-100 trust score\n        uint256 creationTimestamp;\n        uint256 lastUpdateTimestamp;\n        bool isActive;\n        uint256 contentCount;\n        uint256 totalStaked;\n        mapping(string => bool) platformConnections;\n        mapping(bytes32 => ContentProof) contentProofs;\n    }\n    \n    struct ContentProof {\n        bytes32 contentHash;\n        uint256 timestamp;\n        string platformOrigin;\n        address creator;\n        bool isAuthentic;\n        uint8 verificationScore;\n        uint256 challengeStake;\n        bool disputed;\n    }\n    \n    struct VerificationOracle {\n        address oracleAddress;\n        uint256 reputation;\n        bool isActive;\n        string specialization;\n        uint256 totalVerifications;\n        uint256 successfulVerifications;\n    }\n    \n    struct Challenge {\n        bytes32 contentHash;\n        address challenger;\n        uint256 stake;\n        uint256 timestamp;\n        bool resolved;\n        bool upheld; // true if content was found to be inauthentic\n    }\n    \n    // State variables\n    mapping(uint256 => CreatorIdentity) public identities;\n    mapping(address => uint256) public creatorToIdentity;\n    mapping(bytes32 => ContentProof) public contentRegistry;\n    mapping(address => VerificationOracle) public verificationOracles;\n    mapping(bytes32 => Challenge[]) public contentChallenges;\n    \n    // Configuration\n    uint256 public constant MIN_STAKE = 0.01 ether;\n    uint256 public constant MAX_VERIFICATION_LEVEL = 100;\n    uint256 public constant CHALLENGE_PERIOD = 7 days;\n    uint256 public constant ORACLE_CONSENSUS_THRESHOLD = 3;\n    \n    // Modifiers\n    modifier onlyRegisteredCreator() {\n        require(creatorToIdentity[msg.sender] != 0, \"Creator not registered\");\n        _;\n    }\n    \n    modifier onlyVerificationOracle() {\n        require(verificationOracles[msg.sender].isActive, \"Not authorized oracle\");\n        _;\n    }\n    \n    modifier validIdentityId(uint256 identityId) {\n        require(identityId > 0 && identityId <= _identityIds.current(), \"Invalid identity ID\");\n        _;\n    }\n    \n    /**\n     * @dev Register a new creator identity\n     * @param _identityHash IPFS hash containing identity metadata\n     */\n    function registerCreator(string memory _identityHash) external whenNotPaused {\n        require(bytes(_identityHash).length > 0, \"Identity hash cannot be empty\");\n        require(creatorToIdentity[msg.sender] == 0, \"Creator already registered\");\n        \n        _identityIds.increment();\n        uint256 newIdentityId = _identityIds.current();\n        \n        CreatorIdentity storage identity = identities[newIdentityId];\n        identity.walletAddress = msg.sender;\n        identity.identityHash = _identityHash;\n        identity.verificationLevel = 10; // Base verification level\n        identity.creationTimestamp = block.timestamp;\n        identity.lastUpdateTimestamp = block.timestamp;\n        identity.isActive = true;\n        identity.contentCount = 0;\n        identity.totalStaked = 0;\n        \n        creatorToIdentity[msg.sender] = newIdentityId;\n        \n        emit IdentityRegistered(msg.sender, newIdentityId, _identityHash);\n    }\n    \n    /**\n     * @dev Add proof of content authenticity\n     * @param _contentHash Hash of the content\n     * @param _platformOrigin Platform where content was published\n     * @param _signature Creator's signature for verification\n     */\n    function addContentProof(\n        bytes32 _contentHash,\n        string memory _platformOrigin,\n        bytes memory _signature\n    ) external onlyRegisteredCreator nonReentrant whenNotPaused {\n        require(_contentHash != bytes32(0), \"Invalid content hash\");\n        require(bytes(_platformOrigin).length > 0, \"Platform origin required\");\n        require(contentRegistry[_contentHash].timestamp == 0, \"Content already registered\");\n        \n        // Verify signature\n        bytes32 messageHash = keccak256(abi.encodePacked(_contentHash, _platformOrigin, msg.sender));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        address recoveredSigner = ethSignedMessageHash.recover(_signature);\n        require(recoveredSigner == msg.sender, \"Invalid signature\");\n        \n        uint256 identityId = creatorToIdentity[msg.sender];\n        CreatorIdentity storage identity = identities[identityId];\n        \n        ContentProof memory newProof = ContentProof({\n            contentHash: _contentHash,\n            timestamp: block.timestamp,\n            platformOrigin: _platformOrigin,\n            creator: msg.sender,\n            isAuthentic: true,\n            verificationScore: identity.verificationLevel,\n            challengeStake: 0,\n            disputed: false\n        });\n        \n        contentRegistry[_contentHash] = newProof;\n        identity.contentProofs[_contentHash] = newProof;\n        identity.contentCount++;\n        identity.lastUpdateTimestamp = block.timestamp;\n        \n        emit ContentProofAdded(msg.sender, identityId, _contentHash);\n    }\n    \n    /**\n     * @dev Verify platform connection for a creator\n     * @param _creator Creator's address\n     * @param _platform Platform name\n     * @param _platformProof Proof of platform ownership\n     */\n    function verifyPlatformConnection(\n        address _creator,\n        string memory _platform,\n        bytes memory _platformProof\n    ) external onlyVerificationOracle whenNotPaused {\n        uint256 identityId = creatorToIdentity[_creator];\n        require(identityId != 0, \"Creator not registered\");\n        \n        CreatorIdentity storage identity = identities[identityId];\n        require(identity.isActive, \"Identity not active\");\n        \n        // Verify platform proof (implementation depends on platform)\n        bool isValid = _validatePlatformProof(_creator, _platform, _platformProof);\n        require(isValid, \"Invalid platform proof\");\n        \n        // Update platform connection\n        identity.platformConnections[_platform] = true;\n        \n        // Increase verification level\n        if (identity.verificationLevel < MAX_VERIFICATION_LEVEL) {\n            identity.verificationLevel += 15;\n            if (identity.verificationLevel > MAX_VERIFICATION_LEVEL) {\n                identity.verificationLevel = uint8(MAX_VERIFICATION_LEVEL);\n            }\n        }\n        \n        identity.lastUpdateTimestamp = block.timestamp;\n        \n        emit PlatformConnected(_creator, identityId, _platform);\n        emit IdentityVerified(_creator, identityId, identity.verificationLevel);\n    }\n    \n    /**\n     * @dev Challenge content authenticity\n     * @param _contentHash Hash of the content to challenge\n     */\n    function challengeContent(bytes32 _contentHash) external payable whenNotPaused {\n        require(msg.value >= MIN_STAKE, \"Insufficient stake\");\n        require(contentRegistry[_contentHash].timestamp != 0, \"Content not registered\");\n        require(!contentRegistry[_contentHash].disputed, \"Content already disputed\");\n        \n        ContentProof storage proof = contentRegistry[_contentHash];\n        require(proof.isAuthentic, \"Content not marked as authentic\");\n        \n        // Create challenge\n        Challenge memory challenge = Challenge({\n            contentHash: _contentHash,\n            challenger: msg.sender,\n            stake: msg.value,\n            timestamp: block.timestamp,\n            resolved: false,\n            upheld: false\n        });\n        \n        contentChallenges[_contentHash].push(challenge);\n        proof.disputed = true;\n        proof.challengeStake += msg.value;\n        \n        emit VerificationChallenged(_contentHash, msg.sender, msg.value);\n        \n        // Initiate oracle verification process\n        _initiateOracleVerification(_contentHash);\n    }\n    \n    /**\n     * @dev Oracle verification of challenged content\n     * @param _contentHash Hash of the content\n     * @param _isAuthentic Oracle's verdict on authenticity\n     * @param _confidence Confidence level (0-100)\n     */\n    function oracleVerifyContent(\n        bytes32 _contentHash,\n        bool _isAuthentic,\n        uint8 _confidence\n    ) external onlyVerificationOracle whenNotPaused {\n        require(contentRegistry[_contentHash].disputed, \"Content not disputed\");\n        require(_confidence <= 100, \"Invalid confidence level\");\n        \n        VerificationOracle storage oracle = verificationOracles[msg.sender];\n        oracle.totalVerifications++;\n        \n        // Record oracle vote (simplified - in production would use more complex consensus)\n        if (_isAuthentic) {\n            oracle.successfulVerifications++;\n        }\n        \n        // Update oracle reputation based on consensus\n        _updateOracleReputation(msg.sender, _isAuthentic, _confidence);\n        \n        // Check if enough oracles have voted\n        uint256 challengeCount = contentChallenges[_contentHash].length;\n        if (challengeCount >= ORACLE_CONSENSUS_THRESHOLD) {\n            _resolveChallenge(_contentHash, _isAuthentic);\n        }\n    }\n    \n    /**\n     * @dev Update creator identity hash\n     * @param _newIdentityHash New IPFS hash\n     */\n    function updateIdentity(string memory _newIdentityHash) external onlyRegisteredCreator whenNotPaused {\n        require(bytes(_newIdentityHash).length > 0, \"Identity hash cannot be empty\");\n        \n        uint256 identityId = creatorToIdentity[msg.sender];\n        CreatorIdentity storage identity = identities[identityId];\n        \n        identity.identityHash = _newIdentityHash;\n        identity.lastUpdateTimestamp = block.timestamp;\n        \n        emit IdentityUpdated(msg.sender, identityId, _newIdentityHash);\n    }\n    \n    /**\n     * @dev Add or update verification oracle\n     * @param _oracle Oracle address\n     * @param _specialization Oracle specialization\n     */\n    function addVerificationOracle(\n        address _oracle,\n        string memory _specialization\n    ) external onlyOwner {\n        require(_oracle != address(0), \"Invalid oracle address\");\n        require(bytes(_specialization).length > 0, \"Specialization required\");\n        \n        verificationOracles[_oracle] = VerificationOracle({\n            oracleAddress: _oracle,\n            reputation: 100, // Starting reputation\n            isActive: true,\n            specialization: _specialization,\n            totalVerifications: 0,\n            successfulVerifications: 0\n        });\n    }\n    \n    /**\n     * @dev Deactivate verification oracle\n     * @param _oracle Oracle address\n     */\n    function deactivateOracle(address _oracle) external onlyOwner {\n        verificationOracles[_oracle].isActive = false;\n    }\n    \n    /**\n     * @dev Emergency pause contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpause contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    // View functions\n    \n    /**\n     * @dev Get creator's verification level\n     * @param _creator Creator address\n     * @return Verification level (0-100)\n     */\n    function getCreatorVerificationLevel(address _creator) external view returns (uint8) {\n        uint256 identityId = creatorToIdentity[_creator];\n        if (identityId == 0) return 0;\n        return identities[identityId].verificationLevel;\n    }\n    \n    /**\n     * @dev Check if content is authentic\n     * @param _contentHash Content hash\n     * @return isAuthentic Whether content is marked as authentic\n     * @return verificationScore Verification score\n     */\n    function isContentAuthentic(bytes32 _contentHash) external view returns (bool isAuthentic, uint8 verificationScore) {\n        ContentProof memory proof = contentRegistry[_contentHash];\n        return (proof.isAuthentic && !proof.disputed, proof.verificationScore);\n    }\n    \n    /**\n     * @dev Check if creator has platform connected\n     * @param _creator Creator address\n     * @param _platform Platform name\n     * @return Whether platform is connected\n     */\n    function isPlatformConnected(address _creator, string memory _platform) external view returns (bool) {\n        uint256 identityId = creatorToIdentity[_creator];\n        if (identityId == 0) return false;\n        return identities[identityId].platformConnections[_platform];\n    }\n    \n    /**\n     * @dev Get total number of registered identities\n     * @return Total identity count\n     */\n    function getTotalIdentities() external view returns (uint256) {\n        return _identityIds.current();\n    }\n    \n    /**\n     * @dev Get identity information\n     * @param _identityId Identity ID\n     * @return walletAddress Creator's wallet\n     * @return identityHash IPFS hash of identity\n     * @return verificationLevel Verification level\n     * @return isActive Whether identity is active\n     * @return contentCount Number of content pieces\n     */\n    function getIdentityInfo(uint256 _identityId) external view validIdentityId(_identityId) returns (\n        address walletAddress,\n        string memory identityHash,\n        uint8 verificationLevel,\n        bool isActive,\n        uint256 contentCount\n    ) {\n        CreatorIdentity storage identity = identities[_identityId];\n        return (\n            identity.walletAddress,\n            identity.identityHash,\n            identity.verificationLevel,\n            identity.isActive,\n            identity.contentCount\n        );\n    }\n    \n    /**\n     * @dev Get oracle information\n     * @param _oracle Oracle address\n     * @return reputation Oracle reputation\n     * @return isActive Whether oracle is active\n     * @return specialization Oracle specialization\n     * @return successRate Success rate percentage\n     */\n    function getOracleInfo(address _oracle) external view returns (\n        uint256 reputation,\n        bool isActive,\n        string memory specialization,\n        uint256 successRate\n    ) {\n        VerificationOracle memory oracle = verificationOracles[_oracle];\n        uint256 rate = oracle.totalVerifications > 0 \n            ? (oracle.successfulVerifications * 100) / oracle.totalVerifications \n            : 0;\n        return (oracle.reputation, oracle.isActive, oracle.specialization, rate);\n    }\n    \n    // Private functions\n    \n    /**\n     * @dev Validate platform proof\n     * @param _creator Creator address\n     * @param _platform Platform name\n     * @param _proof Platform proof\n     * @return Whether proof is valid\n     */\n    function _validatePlatformProof(\n        address _creator,\n        string memory _platform,\n        bytes memory _proof\n    ) private pure returns (bool) {\n        // Platform-specific validation logic would go here\n        // This is simplified for the example\n        return _proof.length > 0 && _creator != address(0) && bytes(_platform).length > 0;\n    }\n    \n    /**\n     * @dev Initiate oracle verification process\n     * @param _contentHash Content hash to verify\n     */\n    function _initiateOracleVerification(bytes32 _contentHash) private {\n        // In a full implementation, this would distribute the verification task\n        // to active oracles based on their specialization and reputation\n        // For now, this is a placeholder\n    }\n    \n    /**\n     * @dev Update oracle reputation based on consensus\n     * @param _oracle Oracle address\n     * @param _verdict Oracle's verdict\n     * @param _confidence Confidence level\n     */\n    function _updateOracleReputation(\n        address _oracle,\n        bool _verdict,\n        uint8 _confidence\n    ) private {\n        VerificationOracle storage oracle = verificationOracles[_oracle];\n        \n        // Simplified reputation update - in production would be more sophisticated\n        if (_confidence > 80) {\n            oracle.reputation += 1;\n        } else if (_confidence < 50) {\n            if (oracle.reputation > 0) {\n                oracle.reputation -= 1;\n            }\n        }\n    }\n    \n    /**\n     * @dev Resolve challenge based on oracle consensus\n     * @param _contentHash Content hash\n     * @param _isAuthentic Final verdict on authenticity\n     */\n    function _resolveChallenge(bytes32 _contentHash, bool _isAuthentic) private {\n        ContentProof storage proof = contentRegistry[_contentHash];\n        Challenge[] storage challenges = contentChallenges[_contentHash];\n        \n        proof.disputed = false;\n        proof.isAuthentic = _isAuthentic;\n        \n        // Distribute stakes based on verdict\n        uint256 totalStake = proof.challengeStake;\n        uint256 challengeCount = challenges.length;\n        \n        if (_isAuthentic) {\n            // Content is authentic - challengers lose stakes, creator gets reward\n            uint256 identityId = creatorToIdentity[proof.creator];\n            identities[identityId].totalStaked += totalStake;\n            // In production, would transfer funds to creator\n        } else {\n            // Content is inauthentic - challengers get refunded plus reward\n            uint256 rewardPerChallenger = totalStake / challengeCount;\n            for (uint i = 0; i < challengeCount; i++) {\n                challenges[i].resolved = true;\n                challenges[i].upheld = true;\n                // In production, would transfer funds to challengers\n            }\n        }\n        \n        proof.challengeStake = 0;\n    }\n    \n    /**\n     * @dev Emergency function to withdraw stuck funds\n     */\n    function emergencyWithdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    /**\n     * @dev Receive function to accept ETH\n     */\n    receive() external payable {}\n    \n    /**\n     * @dev Fallback function\n     */\n    fallback() external payable {}\n}