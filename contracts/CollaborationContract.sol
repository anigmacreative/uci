// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @title Collaboration Contract\n * @dev Smart contract for managing creator collaborations with automated revenue sharing\n * @author Creative Identity Platform Team\n */\ncontract CollaborationContract is Ownable, ReentrancyGuard, Pausable {\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _collaborationIds;\n    \n    // Events\n    event CollaborationCreated(uint256 indexed collaborationId, address[] participants, uint256 totalBudget);\n    event MilestoneCompleted(uint256 indexed collaborationId, uint256 milestoneIndex, address completedBy);\n    event PaymentDistributed(uint256 indexed collaborationId, uint256 amount, address[] recipients);\n    event CollaborationCompleted(uint256 indexed collaborationId, uint256 totalPaid);\n    event DisputeRaised(uint256 indexed collaborationId, address raisedBy, string reason);\n    event DisputeResolved(uint256 indexed collaborationId, bool inFavorOfRaiser);\n    event FundsWithdrawn(uint256 indexed collaborationId, address participant, uint256 amount);\n    \n    // Enums\n    enum CollaborationStatus {\n        Active,\n        Completed,\n        Disputed,\n        Cancelled,\n        Expired\n    }\n    \n    enum MilestoneStatus {\n        Pending,\n        InProgress,\n        Completed,\n        Disputed\n    }\n    \n    // Structs\n    struct Participant {\n        address wallet;\n        string creatorId;\n        uint256 sharePercentage; // Basis points (10000 = 100%)\n        string role;\n        bool hasAccepted;\n        bool isActive;\n    }\n    \n    struct Milestone {\n        string description;\n        uint256 paymentAmount;\n        uint256 dueDate;\n        address assignedTo;\n        MilestoneStatus status;\n        uint256 completedAt;\n        string deliverable; // IPFS hash or URL\n        uint256 votesRequired; // Number of votes needed for approval\n        mapping(address => bool) approvals;\n        uint256 approvalCount;\n    }\n    \n    struct Collaboration {\n        uint256 id;\n        string name;\n        string description;\n        address creator; // Who initiated the collaboration\n        Participant[] participants;\n        uint256 totalBudget;\n        uint256 totalPaid;\n        uint256 creationDate;\n        uint256 deadline;\n        CollaborationStatus status;\n        bool requiresApproval; // Whether milestones need approval from all participants\n        uint256 milestoneCount;\n        mapping(uint256 => Milestone) milestones;\n        mapping(address => uint256) pendingWithdrawals;\n    }\n    \n    struct Dispute {\n        uint256 collaborationId;\n        address raisedBy;\n        string reason;\n        uint256 timestamp;\n        bool resolved;\n        bool inFavorOfRaiser;\n        mapping(address => bool) votes;\n        uint256 voteCount;\n    }\n    \n    // State variables\n    mapping(uint256 => Collaboration) public collaborations;\n    mapping(uint256 => Dispute) public disputes;\n    mapping(address => uint256[]) public participantCollaborations;\n    \n    uint256 public constant PLATFORM_FEE = 250; // 2.5% in basis points\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant MIN_COLLABORATION_DURATION = 1 days;\n    uint256 public constant MAX_COLLABORATION_DURATION = 365 days;\n    \n    modifier onlyParticipant(uint256 _collaborationId) {\n        bool isParticipant = false;\n        Collaboration storage collab = collaborations[_collaborationId];\n        \n        for (uint i = 0; i < collab.participants.length; i++) {\n            if (collab.participants[i].wallet == msg.sender && collab.participants[i].isActive) {\n                isParticipant = true;\n                break;\n            }\n        }\n        \n        require(isParticipant, \"Not a participant\");\n        _;\n    }\n    \n    modifier onlyCollaborationCreator(uint256 _collaborationId) {\n        require(collaborations[_collaborationId].creator == msg.sender, \"Not collaboration creator\");\n        _;\n    }\n    \n    modifier validCollaboration(uint256 _collaborationId) {\n        require(_collaborationId > 0 && _collaborationId <= _collaborationIds.current(), \"Invalid collaboration ID\");\n        require(collaborations[_collaborationId].status == CollaborationStatus.Active, \"Collaboration not active\");\n        _;\n    }\n    \n    /**\n     * @dev Create a new collaboration\n     * @param _name Name of the collaboration\n     * @param _description Description of the collaboration\n     * @param _participants Array of participant data\n     * @param _totalBudget Total budget for the collaboration\n     * @param _deadline Deadline for completion\n     * @param _requiresApproval Whether milestones need approval\n     */\n    function createCollaboration(\n        string memory _name,\n        string memory _description,\n        Participant[] memory _participants,\n        uint256 _totalBudget,\n        uint256 _deadline,\n        bool _requiresApproval\n    ) external payable whenNotPaused returns (uint256) {\n        require(bytes(_name).length > 0, \"Name required\");\n        require(_participants.length >= 2, \"At least 2 participants required\");\n        require(_participants.length <= 10, \"Max 10 participants allowed\");\n        require(_totalBudget > 0, \"Budget must be greater than 0\");\n        require(_deadline > block.timestamp + MIN_COLLABORATION_DURATION, \"Deadline too soon\");\n        require(_deadline <= block.timestamp + MAX_COLLABORATION_DURATION, \"Deadline too far\");\n        require(msg.value >= _totalBudget, \"Insufficient funding\");\n        \n        // Validate participants and shares\n        uint256 totalShares = 0;\n        bool creatorIncluded = false;\n        \n        for (uint i = 0; i < _participants.length; i++) {\n            require(_participants[i].wallet != address(0), \"Invalid participant address\");\n            require(_participants[i].sharePercentage > 0, \"Share must be greater than 0\");\n            require(bytes(_participants[i].creatorId).length > 0, \"Creator ID required\");\n            \n            totalShares += _participants[i].sharePercentage;\n            \n            if (_participants[i].wallet == msg.sender) {\n                creatorIncluded = true;\n            }\n        }\n        \n        require(totalShares == BASIS_POINTS, \"Shares must total 100%\");\n        require(creatorIncluded, \"Creator must be included as participant\");\n        \n        _collaborationIds.increment();\n        uint256 newCollaborationId = _collaborationIds.current();\n        \n        Collaboration storage newCollab = collaborations[newCollaborationId];\n        newCollab.id = newCollaborationId;\n        newCollab.name = _name;\n        newCollab.description = _description;\n        newCollab.creator = msg.sender;\n        newCollab.totalBudget = _totalBudget;\n        newCollab.totalPaid = 0;\n        newCollab.creationDate = block.timestamp;\n        newCollab.deadline = _deadline;\n        newCollab.status = CollaborationStatus.Active;\n        newCollab.requiresApproval = _requiresApproval;\n        newCollab.milestoneCount = 0;\n        \n        // Add participants\n        for (uint i = 0; i < _participants.length; i++) {\n            newCollab.participants.push(_participants[i]);\n            participantCollaborations[_participants[i].wallet].push(newCollaborationId);\n        }\n        \n        // Refund excess payment\n        if (msg.value > _totalBudget) {\n            payable(msg.sender).transfer(msg.value - _totalBudget);\n        }\n        \n        address[] memory participantAddresses = new address[](_participants.length);\n        for (uint i = 0; i < _participants.length; i++) {\n            participantAddresses[i] = _participants[i].wallet;\n        }\n        \n        emit CollaborationCreated(newCollaborationId, participantAddresses, _totalBudget);\n        \n        return newCollaborationId;\n    }\n    \n    /**\n     * @dev Add a milestone to a collaboration\n     * @param _collaborationId Collaboration ID\n     * @param _description Milestone description\n     * @param _paymentAmount Payment for this milestone\n     * @param _dueDate Due date for the milestone\n     * @param _assignedTo Participant assigned to this milestone\n     */\n    function addMilestone(\n        uint256 _collaborationId,\n        string memory _description,\n        uint256 _paymentAmount,\n        uint256 _dueDate,\n        address _assignedTo\n    ) external validCollaboration(_collaborationId) onlyCollaborationCreator(_collaborationId) {\n        require(bytes(_description).length > 0, \"Description required\");\n        require(_paymentAmount > 0, \"Payment amount must be greater than 0\");\n        require(_dueDate > block.timestamp, \"Due date must be in future\");\n        \n        Collaboration storage collab = collaborations[_collaborationId];\n        \n        // Verify assigned participant\n        bool validParticipant = false;\n        if (_assignedTo != address(0)) {\n            for (uint i = 0; i < collab.participants.length; i++) {\n                if (collab.participants[i].wallet == _assignedTo && collab.participants[i].isActive) {\n                    validParticipant = true;\n                    break;\n                }\n            }\n            require(validParticipant, \"Assigned address not a valid participant\");\n        }\n        \n        uint256 milestoneIndex = collab.milestoneCount;\n        Milestone storage milestone = collab.milestones[milestoneIndex];\n        \n        milestone.description = _description;\n        milestone.paymentAmount = _paymentAmount;\n        milestone.dueDate = _dueDate;\n        milestone.assignedTo = _assignedTo;\n        milestone.status = MilestoneStatus.Pending;\n        milestone.completedAt = 0;\n        milestone.votesRequired = collab.requiresApproval ? collab.participants.length : 1;\n        milestone.approvalCount = 0;\n        \n        collab.milestoneCount++;\n    }\n    \n    /**\n     * @dev Complete a milestone\n     * @param _collaborationId Collaboration ID\n     * @param _milestoneIndex Milestone index\n     * @param _deliverable IPFS hash or URL of the deliverable\n     */\n    function completeMilestone(\n        uint256 _collaborationId,\n        uint256 _milestoneIndex,\n        string memory _deliverable\n    ) external validCollaboration(_collaborationId) onlyParticipant(_collaborationId) {\n        Collaboration storage collab = collaborations[_collaborationId];\n        require(_milestoneIndex < collab.milestoneCount, \"Invalid milestone index\");\n        \n        Milestone storage milestone = collab.milestones[_milestoneIndex];\n        require(milestone.status == MilestoneStatus.Pending || milestone.status == MilestoneStatus.InProgress, \"Milestone not pending\");\n        \n        // Check if assigned to specific participant\n        if (milestone.assignedTo != address(0)) {\n            require(msg.sender == milestone.assignedTo, \"Not assigned to this milestone\");\n        }\n        \n        milestone.deliverable = _deliverable;\n        milestone.completedAt = block.timestamp;\n        \n        if (collab.requiresApproval) {\n            milestone.status = MilestoneStatus.InProgress;\n            // Creator automatically approves their own completion\n            milestone.approvals[msg.sender] = true;\n            milestone.approvalCount = 1;\n        } else {\n            milestone.status = MilestoneStatus.Completed;\n            _distributeMilestonePayment(_collaborationId, _milestoneIndex);\n        }\n        \n        emit MilestoneCompleted(_collaborationId, _milestoneIndex, msg.sender);\n    }\n    \n    /**\n     * @dev Approve a completed milestone\n     * @param _collaborationId Collaboration ID\n     * @param _milestoneIndex Milestone index\n     */\n    function approveMilestone(\n        uint256 _collaborationId,\n        uint256 _milestoneIndex\n    ) external validCollaboration(_collaborationId) onlyParticipant(_collaborationId) {\n        Collaboration storage collab = collaborations[_collaborationId];\n        require(_milestoneIndex < collab.milestoneCount, \"Invalid milestone index\");\n        \n        Milestone storage milestone = collab.milestones[_milestoneIndex];\n        require(milestone.status == MilestoneStatus.InProgress, \"Milestone not ready for approval\");\n        require(!milestone.approvals[msg.sender], \"Already approved\");\n        \n        milestone.approvals[msg.sender] = true;\n        milestone.approvalCount++;\n        \n        // Check if enough approvals received\n        if (milestone.approvalCount >= milestone.votesRequired) {\n            milestone.status = MilestoneStatus.Completed;\n            _distributeMilestonePayment(_collaborationId, _milestoneIndex);\n        }\n    }\n    \n    /**\n     * @dev Raise a dispute\n     * @param _collaborationId Collaboration ID\n     * @param _reason Reason for the dispute\n     */\n    function raiseDispute(\n        uint256 _collaborationId,\n        string memory _reason\n    ) external validCollaboration(_collaborationId) onlyParticipant(_collaborationId) {\n        require(bytes(_reason).length > 0, \"Reason required\");\n        \n        Collaboration storage collab = collaborations[_collaborationId];\n        collab.status = CollaborationStatus.Disputed;\n        \n        Dispute storage dispute = disputes[_collaborationId];\n        dispute.collaborationId = _collaborationId;\n        dispute.raisedBy = msg.sender;\n        dispute.reason = _reason;\n        dispute.timestamp = block.timestamp;\n        dispute.resolved = false;\n        dispute.voteCount = 0;\n        \n        emit DisputeRaised(_collaborationId, msg.sender, _reason);\n    }\n    \n    /**\n     * @dev Vote on a dispute resolution\n     * @param _collaborationId Collaboration ID\n     * @param _inFavorOfRaiser Vote in favor of dispute raiser\n     */\n    function voteOnDispute(\n        uint256 _collaborationId,\n        bool _inFavorOfRaiser\n    ) external onlyParticipant(_collaborationId) {\n        Collaboration storage collab = collaborations[_collaborationId];\n        require(collab.status == CollaborationStatus.Disputed, \"No active dispute\");\n        \n        Dispute storage dispute = disputes[_collaborationId];\n        require(!dispute.resolved, \"Dispute already resolved\");\n        require(!dispute.votes[msg.sender], \"Already voted\");\n        require(msg.sender != dispute.raisedBy, \"Dispute raiser cannot vote\");\n        \n        dispute.votes[msg.sender] = _inFavorOfRaiser;\n        dispute.voteCount++;\n        \n        // Check if majority reached (excluding dispute raiser)\n        uint256 participantCount = collab.participants.length - 1;\n        uint256 requiredVotes = (participantCount / 2) + 1;\n        \n        if (dispute.voteCount >= requiredVotes) {\n            _resolveDispute(_collaborationId, _inFavorOfRaiser);\n        }\n    }\n    \n    /**\n     * @dev Withdraw pending funds\n     * @param _collaborationId Collaboration ID\n     */\n    function withdrawFunds(uint256 _collaborationId) external nonReentrant {\n        Collaboration storage collab = collaborations[_collaborationId];\n        uint256 amount = collab.pendingWithdrawals[msg.sender];\n        \n        require(amount > 0, \"No funds to withdraw\");\n        \n        collab.pendingWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n        \n        emit FundsWithdrawn(_collaborationId, msg.sender, amount);\n    }\n    \n    /**\n     * @dev Emergency withdraw for cancelled/expired collaborations\n     * @param _collaborationId Collaboration ID\n     */\n    function emergencyWithdraw(\n        uint256 _collaborationId\n    ) external onlyParticipant(_collaborationId) nonReentrant {\n        Collaboration storage collab = collaborations[_collaborationId];\n        require(\n            collab.status == CollaborationStatus.Cancelled || \n            collab.status == CollaborationStatus.Expired ||\n            (collab.status == CollaborationStatus.Disputed && block.timestamp > collab.deadline + 30 days),\n            \"Emergency withdrawal not available\"\n        );\n        \n        // Calculate refund based on remaining budget and participant share\n        uint256 remainingBudget = collab.totalBudget - collab.totalPaid;\n        uint256 participantShare = 0;\n        \n        for (uint i = 0; i < collab.participants.length; i++) {\n            if (collab.participants[i].wallet == msg.sender) {\n                participantShare = collab.participants[i].sharePercentage;\n                break;\n            }\n        }\n        \n        uint256 refundAmount = (remainingBudget * participantShare) / BASIS_POINTS;\n        require(refundAmount > 0, \"No refund available\");\n        \n        collab.pendingWithdrawals[msg.sender] = refundAmount;\n        payable(msg.sender).transfer(refundAmount);\n        \n        emit FundsWithdrawn(_collaborationId, msg.sender, refundAmount);\n    }\n    \n    // View functions\n    \n    /**\n     * @dev Get collaboration details\n     * @param _collaborationId Collaboration ID\n     * @return Basic collaboration information\n     */\n    function getCollaboration(uint256 _collaborationId) external view returns (\n        string memory name,\n        string memory description,\n        address creator,\n        uint256 totalBudget,\n        uint256 totalPaid,\n        uint256 deadline,\n        CollaborationStatus status,\n        uint256 participantCount,\n        uint256 milestoneCount\n    ) {\n        Collaboration storage collab = collaborations[_collaborationId];\n        return (\n            collab.name,\n            collab.description,\n            collab.creator,\n            collab.totalBudget,\n            collab.totalPaid,\n            collab.deadline,\n            collab.status,\n            collab.participants.length,\n            collab.milestoneCount\n        );\n    }\n    \n    /**\n     * @dev Get collaboration participants\n     * @param _collaborationId Collaboration ID\n     * @return Array of participants\n     */\n    function getParticipants(uint256 _collaborationId) external view returns (Participant[] memory) {\n        return collaborations[_collaborationId].participants;\n    }\n    \n    /**\n     * @dev Get milestone details\n     * @param _collaborationId Collaboration ID\n     * @param _milestoneIndex Milestone index\n     * @return Milestone information\n     */\n    function getMilestone(uint256 _collaborationId, uint256 _milestoneIndex) external view returns (\n        string memory description,\n        uint256 paymentAmount,\n        uint256 dueDate,\n        address assignedTo,\n        MilestoneStatus status,\n        uint256 completedAt,\n        string memory deliverable,\n        uint256 approvalCount,\n        uint256 votesRequired\n    ) {\n        Milestone storage milestone = collaborations[_collaborationId].milestones[_milestoneIndex];\n        return (\n            milestone.description,\n            milestone.paymentAmount,\n            milestone.dueDate,\n            milestone.assignedTo,\n            milestone.status,\n            milestone.completedAt,\n            milestone.deliverable,\n            milestone.approvalCount,\n            milestone.votesRequired\n        );\n    }\n    \n    /**\n     * @dev Get participant's collaborations\n     * @param _participant Participant address\n     * @return Array of collaboration IDs\n     */\n    function getParticipantCollaborations(address _participant) external view returns (uint256[] memory) {\n        return participantCollaborations[_participant];\n    }\n    \n    /**\n     * @dev Get pending withdrawal amount\n     * @param _collaborationId Collaboration ID\n     * @param _participant Participant address\n     * @return Pending withdrawal amount\n     */\n    function getPendingWithdrawal(uint256 _collaborationId, address _participant) external view returns (uint256) {\n        return collaborations[_collaborationId].pendingWithdrawals[_participant];\n    }\n    \n    // Private functions\n    \n    /**\n     * @dev Distribute payment for completed milestone\n     * @param _collaborationId Collaboration ID\n     * @param _milestoneIndex Milestone index\n     */\n    function _distributeMilestonePayment(uint256 _collaborationId, uint256 _milestoneIndex) private {\n        Collaboration storage collab = collaborations[_collaborationId];\n        Milestone storage milestone = collab.milestones[_milestoneIndex];\n        \n        uint256 paymentAmount = milestone.paymentAmount;\n        uint256 platformFee = (paymentAmount * PLATFORM_FEE) / BASIS_POINTS;\n        uint256 distributionAmount = paymentAmount - platformFee;\n        \n        address[] memory recipients = new address[](collab.participants.length);\n        uint256 recipientCount = 0;\n        \n        // Distribute according to participant shares\n        for (uint i = 0; i < collab.participants.length; i++) {\n            if (collab.participants[i].isActive) {\n                uint256 participantPayment = (distributionAmount * collab.participants[i].sharePercentage) / BASIS_POINTS;\n                collab.pendingWithdrawals[collab.participants[i].wallet] += participantPayment;\n                recipients[recipientCount] = collab.participants[i].wallet;\n                recipientCount++;\n            }\n        }\n        \n        collab.totalPaid += paymentAmount;\n        \n        // Resize recipients array\n        address[] memory finalRecipients = new address[](recipientCount);\n        for (uint i = 0; i < recipientCount; i++) {\n            finalRecipients[i] = recipients[i];\n        }\n        \n        emit PaymentDistributed(_collaborationId, distributionAmount, finalRecipients);\n        \n        // Check if collaboration is complete\n        bool allMilestonesComplete = true;\n        for (uint i = 0; i < collab.milestoneCount; i++) {\n            if (collab.milestones[i].status != MilestoneStatus.Completed) {\n                allMilestonesComplete = false;\n                break;\n            }\n        }\n        \n        if (allMilestonesComplete) {\n            collab.status = CollaborationStatus.Completed;\n            emit CollaborationCompleted(_collaborationId, collab.totalPaid);\n        }\n    }\n    \n    /**\n     * @dev Resolve a dispute\n     * @param _collaborationId Collaboration ID\n     * @param _inFavorOfRaiser Whether dispute was resolved in favor of raiser\n     */\n    function _resolveDispute(uint256 _collaborationId, bool _inFavorOfRaiser) private {\n        Collaboration storage collab = collaborations[_collaborationId];\n        Dispute storage dispute = disputes[_collaborationId];\n        \n        dispute.resolved = true;\n        dispute.inFavorOfRaiser = _inFavorOfRaiser;\n        \n        if (_inFavorOfRaiser) {\n            // Cancel collaboration and enable refunds\n            collab.status = CollaborationStatus.Cancelled;\n        } else {\n            // Resume collaboration\n            collab.status = CollaborationStatus.Active;\n        }\n        \n        emit DisputeResolved(_collaborationId, _inFavorOfRaiser);\n    }\n    \n    // Admin functions\n    \n    /**\n     * @dev Pause contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpause contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    /**\n     * @dev Withdraw platform fees\n     */\n    function withdrawPlatformFees() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    /**\n     * @dev Get total collaborations count\n     * @return Total number of collaborations\n     */\n    function getTotalCollaborations() external view returns (uint256) {\n        return _collaborationIds.current();\n    }\n    \n    receive() external payable {}\n    fallback() external payable {}\n}